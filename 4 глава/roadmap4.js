/*1.  this - идентификатор, rоторый ссылается на контекст выполнения

В глобальном контексте выполнения (за пределами каких-либо функций) this ссылается на глобальный объект вне зависимости от режима (строгий или нестрогий).

В пределах функции значение this зависит от того, каким образом вызвана функция.

function f(){
  return this;
}

//В браузере:
f() === window;  //window - глобальный объект в браузере
/ В Node:
f1() === global; // global - глобальный объект в Node

В строгом режиме, если значение this не установлено в контексте выполнения, оно остаётся undefined

function f1(){
  'use strict';
  return this
}
f1() === undefined; // true

Для того, чтобы при вызове функции установить this в определённое значение, используйте call() или apply()

Стрелочные функции создают замыкания для значения this из окружающего контекста выполнения
*/

!!!вопрос когда функция возвращает весь объект через this а когда она вернет глобальный контекст

//Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.

//Когда функция используется как конструктор (с ключевым словом new ), this связано с создаваемым новым объектом.

//Примечание: по умолчанию конструктор возвращает объект, на который ссылается this, но он может вернуть и другой объект (если возвращаемое значение не является объектом, тогда будет возвращён объект с this).

function C() {
  this.a = 37;
}

let o = new C();
console.log(o.a); // logs 37

function C2() {
!!  this.a = 37;
  return { a: 38 };////////
}

o = new C2();
console.log(o.a); // logs 38


/*2. Как "потерять" this?

//Потеря контекста
Если метод передаётся отдельно от объекта (например, в переменную или как колбэк), то this теряется и больше не ссылается на объект.

Как только метод передаётся отдельно от объекта – this теряется.

*/
let user = {
  name: 'Ann',
  greet()
{
  console.log(`hi, ${this.name}`);
}
};

//Вызов метода как метода объекта — работает
user.greet(); //hi, Ann

// Потеря контекста при передаче метода
let freetFunc = user.greet;
freetFunc(); // hi, undefined!

//В строке let freetFunc = user.greet; метод greet копируется в переменную freetFunc, но связь с объектом user теряется.

//При вызове freetFunc(), this больше не ссылается на user, а становится undefined (в строгом режиме) или ссылается на глобальный объект (в нестрогом режиме).

//3. как не терять this

//Используйте bind, чтобы привязать контекст.

let freetFunc = user.greet.bind(user); // Привязываем контексn
freetFunc(); //hi, Ann


//Используйте стрелочные функции, если нужно сохранить контекст. - в setTimeout

//Используйте call или apply для явного указания контекста.
let freetFunc = user.greet;
freetFunc.call(user);
freetFunc.apply(user);

//4. Чему равен this в свойствах объекта?

//- объекту

//Чему равен this в геттерах/сеттерах объекта?

//самому объекту, которому принадлежат эти методы. Это связано с тем, что геттеры и сеттеры являются методами объектов, и при их вызове this ссылается на объект, который их содержит.


//Чему равен this внутри функции-стрелки?

// контексту в котором она создана
//Как сделать, чтобы объект: был равен определенному числу?
//В JavaScript объект не может быть напрямую равен числу, так как объекты и примитивы (например, числа) — это разные типы данных. Однако, если вы хотите, чтобы объект вел себя как число (например, при математических операциях или сравнениях), можно использовать специальные методы, такие как valueOf и toString.


let obj = {
  value: 42,
  valueOf(){
    return this.value;// Возвращает число

  }
};
console.log(typeof obj.value);//number
console.log(obj == 42);//true
console.log(obj + 10);  
console.log(obj > 40);  

//Метод toString также может быть использован для преобразования объекта в строку, которая может быть интерпретирована как число.

let obj = {
  value: 42,
  toString(){
    return this.value.toString();// Возвращает строку "42"
  }
  };
  console.log(obj == 42);
  console.log(typeof obj.value)
  

  // этом случае вы переопределили метод toString, чтобы он возвращал строковое представление значения value (то есть "42").


  //Когда объект сравнивается с примитивом, JavaScript пытается преобразовать объект в примитив, вызывая методы valueOf и toString.

//По умолчанию метод valueOf возвращает сам объект, а toString возвращает строку "[object Object]".

//Как сделать, чтобы объект:был равен определенной строке?
//Чтобы сделать так, чтобы объект в JavaScript был равен определенной строке, можно переопределить метод toString() у этого объекта. Метод toString() вызывается автоматически, когда объект преобразуется в строку

//obj > 0 // true. Как это сделать?

//Чтобы obj > 0 возвращал true, нужно, чтобы при преобразовании объекта в примитивное значение возвращалось число больше 0.

let obj = {
value: 32;
valueOf (){
  return this.value;// Возвращаем значение для сравнения  объект равен числу
}
}
console.log(obj > 0); // true

const obj = {
    value: 1,
    toString() {
        return this.value.toString(); // Возвращаем строку "1"
    }
};

console.log(obj > 0); // true


