while (condition){ 
    // код
    // также называемый "телом цикла"
    //Код из тела цикла выполняется, пока условие condition истинно
}
let i = 0;
while(i<3){// выводит 0, затем 1, затем 2
    alert (i)
    i++;}
    let  i = 3;
    while(i){
        alert (i);// когда i будет равно 0, условие станет ложным, и цикл остановится
        i--
    }
    let i = 3;
while (i) alert(i--);

do{
      // тело цикла
} while(condition);
let i = 0
do{
    alert (i);
    i++
}while (i<3);//Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным. На практике чаще используется форма с предусловием: while(…) {…}.

for (начало; условие; шаг) {
    // ... тело цикла ...
  }
  for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
    alert(i);
  }

  В целом, алгоритм работы цикла выглядит следующим образом:

Выполнить начало
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ ...

let i = 0	Выполняется один раз при входе в цикл
условие	i < 3	Проверяется перед каждой итерацией цикла.
Если оно вычислится в false, цикл остановится.
тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.
шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.

let i = 0;
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { alert(i); i++ }
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { alert(i); i++ }
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { alert(i); i++ }
// ...конец, потому что теперь i == 3
let i = 0;

for (i = 0; i < 3; i++) { // используем существующую переменную
  alert(i); // 0, 1, 2
}

alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла
let i = 0 ;
for(; i<3;i++){
    alert (i)// 0, 1, 2
    }

    let i = 0
    for(; i<3;){
        alert(i++)
    }//Это сделает цикл аналогичным while (i < 3).

let sum = 0 ;
while (true){
    let value = +prompt ("Type a number", "");
    if (!value) break;//(*)
}sum += value;

}
alert( 'Сумма: ' + sum );

for (let i = 0; i < 10; i++) {

    // если true, пропустить оставшуюся часть тела цикла
    if (i % 2 == 0) continue;
  
    alert(i); // 1, затем 3, 5, 7, 9
  }
  Для чётных значений i, директива continue прекращает выполнение тела цикла и передаёт управление на следующую итерацию for (со следующим числом). Таким образом alert вызывается только для нечётных значений.
  
  console.log(1);
  for (let i = 0; i<4; i++){
  };
let x = 0;
  while(x<3){//while true
console.log(x);
x++
break;.. сначала проверяем потом делаем
  };

  let word = "";
  while(word.length<5){
    const value = prompt("Write a letter")
    if(value.length ===0){
        break;
    }
    word = word+value;
    console.log(word);
  };

let x = 0;
  do{ x++// сначала деланм потом проверяем
    console.log(x);

  }while (x<5);
  for (let i =0; i<10; i++){
    if (i%2==0) continue;
    alert(i);// 1, затем 3, 5, 7, 9

  }

   (let i = 0; i < 10; i++) {

    if (i % 2) {
      alert( i );
    }
  
  }
  if (i > 5) {
    alert(i);
  } else {
    continue;
  };

  for (let i = 0; i<3; i++){
    for(let j = 0; j <3; j++)
  }let input = prompt(`Значение на координатах`(${i}, ${j}, ''));
}
} alert('Готово!');

outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)

    // сделать что-нибудь со значениями...
  }
}

alert('Готово!');
//В примере выше это означает, что вызовом break outer будет разорван внешний цикл до метки с именем outer.

Таким образом управление перейдёт со строки, помеченной (*), к alert('Готово!').

while – Проверяет условие перед каждой итерацией.
do..while – Проверяет условие после каждой итерации.
for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.
let i = 0;
while(++i<5) alert(i)//1/2/3/4
let i = 0;
while (i++ < 5) alert( i );// 1 2 3 4 5
Первое значение: i = 1, так как операция ++i сначала увеличит i, а потом уже произойдёт сравнение и выполнение alert.

Далее 2, 3, 4… Значения выводятся одно за другим. Для каждого значения сначала происходит увеличение, а потом – сравнение, так как ++ стоит перед переменной.

При i = 4 произойдёт увеличение i до 5, а потом сравнение while (5 < 5) – это неверно. Поэтому на этом цикл остановится, и значение 5 выведено не будет.

От
2.Первая итерация: i равно 0, проверка 0 < 5 возвращает true, затем i увеличивается до 1, и выводится 1.
Четвертая итерация: i равно 3, проверка 3 < 5 возвращает true, i увеличивается до 4, и выводится 4.

Пятая итерация: i равно 4, проверка 4 < 5 возвращает true, i увеличивается до 5, и выводится 5.

Шестая итерация: i равно 5, проверка 5 < 5 возвращает false, и цикл заканчивается.
Таким образом, если вы используете i++, вы получите значения 0, 1, 2, так как данное значение используется перед увеличением. Если вы используете ++i, вы получите значения 1, 2, 3, так как i будет увеличиваться перед использованием в alert.

Итак, итоговые выводы будут:


Для i++: 0, 1, 2.

Для ++i: 1, 2, 3.


outer:
for (let i = 0; i<3; i++){}

label: {
  // ...
  break label; // работает
  // ...
}

let i = 3;
while (i){
  alert( i--)//3 2 1 
};
  let i = 0;
  while(++1 <5) alert(i);//1 2 3 4

  let i = 0;
while (i++ < 5) alert( i );
// 1 2 3 4 5
Первое значение: i = 1. Остановимся на нём подробнее. Оператор i++ увеличивает i, возвращая старое значение, так что в сравнении i++ < 5 будет участвовать i = 0 (в отличие от ++i < 5).

for (let i = 0; i<5; i++);
//0 1 2 3 4 
for (let i = 0; i < 5; ++i) alert( i );
//0 1 2 3 4 
Такой результат обусловлен алгоритмом работы for:

Выполнить единожды присваивание i = 0 перед чем-либо (начало).
Проверить условие i < 5
Если true – выполнить тело цикла alert(i), и затем i++
Увеличение i++ выполняется отдельно от проверки условия (2), значение i при этом не используется, поэтому нет никакой разницы между i++ и ++i.

for (let i = 2; i <= 10; i++) {
if (i % 2 == 0){
  alert(i);
}};

for (let i = 0; i < 3; i++){
  alert(` number ${i}!`);//0 1 2

  let i = 0;
  while (i<3){
    alert(` number ${i}!`);
    i++
  }
}

let i; 
  do{
    i = prompt( 'ввести числоо больше 100','');
  for (i > 100
  if(i<100)
}
 let num = 0;
 for (; num<5; num ++ ){///Точка с запятой в этом случае указывает, что вы намеренно пропускаете инициализацию. Вы
  console.log(num);
  if(num ==2)break;
 }
 console.log( `work is done, num =$(num)`);
 let num = 0;
 for(; num<5; num++){
  if(num ==2) continue;
  console.log(num);//0 1 3 4 
 }
 let num = 0;
 for(; num<5; num++){
  if(num ==2) break;
  console.log(num);
 }//0 1 

 let sum = 0
 for (let i =1; i<=100; i++) {
  sum+=i;
 } console.log(sum);

 let c = 0; 
for (let y = 100; y >= 1; y--) { 
    c -= y; 
} 
console.log(c);
 let i =1;
 for(; i<=20; i++){
  if(i%2==0){ console.log(` ${i}: четное`);}
  else{ console.log("нечетное");}
 };

 let i = 10;
 for(; i>=0;i--){
  console.log(`${i}, Time is over`);
 };
 let i =10;
 for(; i>=0; i--){
  console.log(i*i);
 }
 часть		
начало	let i = 0	Выполняется один раз при входе в цикл
условие	i < 3	Проверяется перед каждой итерацией цикла.
Если оно вычислится в false, цикл остановится.
тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.
шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.
В целом, алгоритм работы цикла выглядит следующим образом:

for(let i = 0; i < 10; i++){
  
  if(i % 2){
    console.log(i);
  }
}

for (let i = 0; i < 10; i++){
  i % 2 && console.log(i);
}