let name = 'Ilya';
alert(`hello ${1}`); // hello 1
alert(`hello ${'name'}`); // hello name
alert( ` hello ${name}`); // hello Ilya

/*В JavaScript есть 8 основных типов данных.

Семь из них называют «примитивными» типами данных:
number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null для неизвестных значений – отдельный тип, имеющий одно значение null.
undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
symbol для уникальных идентификаторов.
И один не является «примитивным» и стоит особняком:
object для более сложных структур данных.
Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

Имеет две формы: typeof x или typeof(x).
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.
В следующих главах мы сконцентрируемся на примитивных значениях, а когда познакомимся с ними, перейдём к объектам.
*/

let name1 = prompt('what is your name?', '');
console.log(name1);
/*Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.

Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).

Преобразование подчиняется правилам:

	null - 0
undefined -	NaN
Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).
0, null, undefined, NaN, ""	false
любое другое значение	true
При строгом равенстве ===
Эти значения различны, так как различны их типы.

alert( null === undefined ); // false
При нестрогом равенстве ==
Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.

alert( null == undefined ); // true
alert( null >= 0 ); // (3) true  */

5 > 4 //true
"ананас" > "яблоко" //false
"2" > "12" //true
undefined == null // true
undefined === null //false
null == "\n0\n"// false
null === +"\n0\n" // false

alert( null || 2 || undefined ); // 2
alert( alert(1) || 2 || alert(3) ); // 1 2 
alert( null || 2 && 3 || 4 ); //3
let value = NaN;

value &&= 10;
value ||= 20;
value &&= 30;
value ||= 40;
alert(value); //30

let age;
if(age >= 14 && age <=90){
    console.log(age);
};

let age;
if(!(age >= 14 && <= 90 ));
if (age < 14 || age > 90)


    let name = prompt('who is it?', '');
    if( name === 'Admin'){
      let password = prompt('What is your password?', '');
      if (password === 'Я главный'){
        alert('Здравствуйте!');
        } else if (password === "" || password === null) {
            alert('Отменено');
        } else { 
            alert('Неверный пароль');
        }
    
        } else if( name === '' || name === null){
            alert('Отменено');
        } else { 
            alert('Я вас не знаю');
        }

        // сравнение возвращает  логическое значение
    //При сравнении значений разных типов JavaScript приводит каждое из них к числу.

//Строки сравниваются посимвольно в лексикографическом порядке.
NaN == NaN //false
NaN === NaN//false

/*switch не называется циклом, потому что он служит для выполнения выбора одного из нескольких вариантов, а не для повторяющихся действий
//Конструкция if позволяет проверять одно или несколько условий и выполнять определенный код, если условие истинно. 
Конструкция switch используется для выбора одного из нескольких вариантов в зависимости от значения выражения. Это удобнее, когда нужно проверять одно значение на равенство нескольким вариантам.
//Функции — это самостоятельные блоки кода, предназначенные для выполнения конкретной задачи */

function checkAge(age) {
    if (age > 18) {
      return true;
    }
    
    return confirm('Родители разрешили?');
  };
  function min(a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };

  function pow(x,n){
    let res = x;
    for(let i = 1; i< n; i++){
        res *=x
    }
    return res;
  }
  let x = prompt("x?", '');
let n = prompt("n?", '');
if( n >= 1 && n % 1 == 0){
    alert( pow(x, n) );
}else{
      alert(`Степень ${n} не подходит`)
}

for(let i = 0; i < 10; i++){
  
}
console.log(i)/* Переменная i объявлена с помощью let, поэтому она имеет блочную область видимости и доступна только внутри цикла.

Попытка обратиться к i после цикла вызовет ошибку ReferenceError, так как i выходит за пределы своей области видимости.

Вывод:
Copy
ReferenceError: i is not defined*/

for(let i = 0; i < 10; ){
  console.log(i++)}/*Условие i < 10 проверяется перед каждой итерацией. Если оно истинно, выполняется тело цикла.

  Тело цикла:
  
  Внутри тела цикла:
  
  console.log(i++) выводит текущее значение i, а затем увеличивает его на 1.
  
  i++ — это постфиксный инкремент. Сначала используется текущее значение i, а затем оно увеличивается на 1.*/

  for(let i = 0; i < 10; ){
    console.log(++i)} /* console.log(++i) сначала увеличивает значение i на 1, а затем выводит его.
    1
2
3
4
5
6
7
8
9
10
++i — это префиксный инкремент. Сначала значение i увеличивается на 1, а затем используется.*/
