/*class MyClass { // методы класса

  constructor() { }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
  Затем используйте вызов new MyClass() для создания нового объекта со всеми перечисленными методами.

При этом автоматически вызывается метод constructor(), в нём мы можем инициализировать объект.


*/
class User {
	constructor(name) {
		this.name = name;
	}
	sayHi() {
		console.log(this.name);
	}
}
// Использование:
let user = new User('Иван');
user.sayHi();
/*Когда вызывается new User("Иван"):

Создаётся новый объект.
constructor запускается с заданным аргументом и сохраняет его в this.name.
*/
//Методы в классе не разделяются запятой
//Синтаксис классов отличается от литералов объектов, не путайте их. Внутри классов запятые не требуются.
//в JavaScript класс – это разновидность функции.

{
	class User {
		constructor(name) {
			this.name = name;
		}
		sayHi() {
			alert(this.name);
		}
	}
	console.log(typeof User); //VM47:9 function
	alert(User === User.prototype.constructor); // true

	// Методы находятся в User.prototype, например:
	alert(User.prototype.sayHi); // sayHi() { alert(this.name); }

	// в прототипе ровно 2 метода
	alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
}
/*Вот что на самом деле делает конструкция class User {...}:

Создаёт функцию с именем User, которая становится результатом объявления класса. Код функции берётся из метода constructor (она будет пустой, если такого метода нет).
Сохраняет все методы, такие как sayHi, в User.prototype.
При вызове метода объекта new User он будет взят из прототипа, как описано в главе F.prototype. Таким образом, объекты new User имеют доступ к методам класса.

*/
//Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[IsClassConstructor]]: true. Поэтому это не совсем то же самое, что создавать её вручную.

//В отличие от обычных функций, конструктор класса не может быть вызван без new:
{
	class User {
		constructor() {}
	}
	console.log(typeof User); // function
	User(); // Error: Class constructor User cannot be invoked without 'new'
}
//Кроме того, строковое представление конструктора класса в большинстве движков JavaScript начинается с «class …»
{
	class User {
		constructor() {}
	}
	alert(User); // class User { ... }
}
//Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable в false для всех методов в "prototype".
//Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.
//Как и функции, классы можно определять внутри другого выражения, передавать, возвращать, присваивать
//Пример Class Expression (по аналогии с Function Expression):

{
	let User = class {
		sayHi() {
			console.log('hi');
		}
	};
}
/*Аналогично Named Function Expression, Class Expression может иметь имя.

Если у Class Expression есть имя, то оно видно только внутри класса:*/
{
	// "Named Class Expression"
	// (в спецификации нет такого термина, но происходящее похоже на Named Function Expression)
	let User = class MyClass {
		sayHi() {
			console.log(MyClass); // имя MyClass видно только внутри класса
		}
	};
	new User().sayHi(); // работает, выводит определение MyClass Это работает, потому что мы внутри области видимости класса
	alert(MyClass); // ошибка, имя MyClass не видно за пределами класса
}
//Ошибка, потому что снаружи MyClass не существует
//Фабрика классов
{
	function makeClass(phrase) {
		// объявляем класс и возвращаем его
		return class {
			sayHi() {
				console.log(phrase);
			}
		};
	}
	let User = makeClass('Hi');
	new User().sayHi(); // Привет
}
/*makeClass("Привет") возвращает класс с зафиксированной фразой

Сохраняем этот класс в переменную User

Результат:

User теперь ведёт себя как обычный класс

При создании экземпляра (new User()) он имеет метод sayHi()

Метод использует значение phrase, которое было передано при создании

*/
//Геттеры и сеттеры создаются на User.prototype
{
	class User {
		constructor(name) {
			// вызывает сеттер
			this.name = name;
		}
		get name() {
			return this._name;
		}
		set name(value) {
			if (value.length < 4) {
				console.log('Имя слишком короткое.');
				return;
			}
			this.name = value;
		}
	}
	let user = new User('ivan');
	alert(user.name); // Иван

	user = new User(''); // Имя слишком короткое.
}
//При объявлении класса геттеры/сеттеры создаются на User.prototype, вот так:
{
	Object.definePoroperties(User.prototype, {
		name: {
			get() {
				return this._name;
			},
			set(name) {
				//
			},
		},
	});
}
//Пример с вычисляемым свойством в скобках [...]:
{
	class User {
		['say ' + 'Hi']() {
			console.log('hi');
		}
	}
	new User().sayHi();
}
{
	class User {
		name = 'Аноним'; // Поле класса (добавляется в экземпляр)

		sayHi() {
			// Метод класса (добавляется в прототип)
			alert(`Привет, ${this.name}!`);
		}
	}

	let user = new User(1);
	console.log(user);
}
//методы, геттеры и сеттеры записываются в MyClass.prototype.

{
	//Класс Clock написан в функциональном стиле. Перепишите его, используя современный синтаксис классов.
}
//Наследование классов – это способ расширения одного класса другим классом

class Animal {
	constructor(name) {
		this.speed = 0;
		this.name = name;
	}
	run(speed) {
		this.speed = speed;
		console.log(`${this.name} runs with speed ${this.speed}`);
	}
	stop() {
		this.speed = 0;
		alert(`${this.name} стоит неподвижно.`);
	}
}
let animal = new Animal('Мой питомец');

//Поскольку кролики – это животные, класс Rabbit должен быть основан на Animal, и иметь доступ к методам животных, так чтобы кролики могли делать то, что могут делать «общие» животные
//Синтаксис для расширения другого класса следующий: class Child extends Parent
//создадим class Rabbit, который наследуется от Animal:

class Rabbit extends Animal {
	hide() {
		console.log(`${this.name} прячется!`);
	}
}
let rabbit = new Rabbit('Белый кролик');
rabbit.run(5);
rabbit.hide();
//Объект класса Rabbit имеет доступ как к методам Rabbit, таким как rabbit.hide(), так и к методам Animal, таким как rabbit.run().
//Внутри ключевое слово extends работает по старой доброй механике прототипов. Оно устанавливает Rabbit.prototype.[[Prototype]] в Animal.prototype. Таким образом, если метода не оказалось в Rabbit.prototype, JavaScript берет его из Animal.prototype
//Rabbit.prototype.__proto__ (или [[Prototype]]) автоматически устанавливается в Animal.prototype.

//Конструктор Rabbit.prototype.constructor ссылается на сам Rabbit.
//rabbit → Rabbit.prototype → Animal.prototype → Object.prototype → null

/*Например, чтобы найти метод rabbit.run, движок проверяет (снизу вверх на картинке):

Объект rabbit (не имеет run).
Его прототип, то есть Rabbit.prototype (имеет hide, но не имеет run).
Его прототип, то есть (вследствие extends) Animal.prototype, в котором, наконец, есть метод run.*/
/*После extends разрешены любые выражения
Синтаксис создания класса допускает указывать после extends не только класс, но и любое выражение.

Пример вызова функции, которая генерирует родительский класс:

*/ {
	function f(phrase) {
		return class {
			sayHi() {
				console.log(phrase);
			}
		};
	}
	class User extends f('hi') {} //Наследуется от класса, который вернула f('hi')
	//явно объявили его строкой class User extends f('hi') {}.

	new User().sayHi(); //hi;
	console.log(User);
}
/*Теперь давайте продвинемся дальше и переопределим метод. По умолчанию все методы, не указанные в классе Rabbit, берутся непосредственно «как есть» из класса Animal.

Но если мы укажем в Rabbit собственный метод, например stop(), то он будет использован вместо него:

*/ {
	class Rabbit extends Animal {
		stop() {
			// ...теперь это будет использоваться для rabbit.stop()
			// вместо stop() из класса Animal
		}
	}
}
/*У классов есть ключевое слово "super" для таких случаев.

super.method(...) вызывает родительский метод.
super(...) для вызова родительского конструктора (работает только внутри нашего конструктора).
*/
//Пусть наш кролик автоматически прячется при остановке:

{
	class Animal {
		constructor(name) {
			this.speed = 0;
			this.name = name;
		}
		run(speed) {
			this.speed = speed;
			alert(`${this.name} бежит со скоростью ${this.speed}.`);
		}
		stop() {
			this.speed = 0;
			alert(`${this.name} стоит.`);
		}
	}
	class Rabbit extends Animal {
		hide() {
			alert(`${this.name} прячется!`);
		}
		stop() {
			super.stop(); // вызываем родительский метод stop //Гарантирует, что будет вызван именно метод родителя (Animal.prototype.stop), даже если в текущем классе (Rabbit) есть одноимённый метод.

			this.hide();
		}
	}
	let rabbit = new Rabbit('Bunny');
	rabbit.run(5); // Белый кролик бежит со скоростью 5.
	rabbit.stop(); // Белый кролик стоит. Белый кролик прячется!
}
//Теперь у класса Rabbit есть метод stop, который вызывает родительский super.stop() в процессе выполнения.
//Как упоминалось в главе Повторяем стрелочные функции, стрелочные функции не имеют super.
//При обращении к super стрелочной функции он берётся из внешней функции:

{
	class Rabbit extends Animal {
		stop() {
			setTimeout(() => super.stop(), 1000); // вызывает родительский stop после 1 секунды
		}
	}
}
//setTimeout вызывает функцию в глобальном контексте
//Обычная функция при вызове через setTimeout теряет исходный this (если не привязан через .bind()), а super вообще не существует вне методов класса
//Стрелочная функция замыкает super и this из внешнего метода класса.
//Обычная функция не запоминает super (и this) при передаче в асинхронные API (вроде setTimeout).

// примере super в стрелочной функции тот же самый, что и в stop(), поэтому метод отрабатывает как и ожидается. Если бы мы указали здесь «обычную» функцию, была бы ошибка:
//Согласно спецификации, если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой «пустой» конструктор:
{
	class Rabbit extends Anumal {
		// генерируется для классов-потомков, у которых нет своего конструктора

		constructor(...args) {
			super(...args);
		}
	}
}
//Как мы видим, он просто вызывает конструктор родительского класса. Так будет происходить, пока мы не создадим собственный конструктор
//Конструкторы в наследуемых классах должны обязательно вызывать super(...), и (!) делать это перед использованием this.
//В JavaScript существует различие между «функцией-конструктором наследующего класса» и всеми остальными. В наследующем классе соответствующая функция-конструктор помечена специальным внутренним свойством [[ConstructorKind]]:"derived".
/*Разница в следующем:

Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его this .
Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса.
*/
/*Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса.
Поэтому, если мы создаём собственный конструктор, мы должны вызвать super, в противном случае объект для this не будет создан, и мы получим ошибку.

*/
//Чтобы конструктор Rabbit работал, он должен вызвать super() до того, как использовать this, чтобы не было ошибки:

{
	class Animal {
		constructor(name) {
			this.speed = 0;
			this.name = name;
		}
	}
	class Rabbit extends Animal {
		constructor(name, earLength) {
			super(name);
			this.earLength = earLength;
		}
	}
	// теперь работает
	let rabbit = new Rabbit('Белый кролик', 10);
	alert(rabbit.name); // Белый кролик
	alert(rabbit.earLength); // 10
}
{
	class Animal {
		name = 'animal';
		constructor() {
			console.log(this.name);
		}
	}
	class Rabbit extends Animal {
		name = 'rabbit';
	}
	new Animal(); // animal
	new Rabbit(); // animal
}
/*Здесь, класс Rabbit расширяет Animal и переопределяет поле name своим собственным значением.

В Rabbit нет собственного конструктора, поэтому вызывается конструктор Animal.

*/
//Другими словами, родительский конструктор всегда использует своё собственное значение поля, а не переопределённое
//super(name) в вашем примере — это передача параметра в конструктор Animal, потому что он требует name.
/*Если бы Animal не имел параметров, можно было писать просто super().

super.method() — это совсем другая операция (вызов метода родителя), она не связана с конструкторами*/
//Итак, new Rabbit() вызывает super(), таким образом, выполняя родительский конструктор, и (согласно правилу для производных классов) только после этого инициализируются поля его класса. На момент выполнения родительского конструктора ещё нет полей класса Rabbit, поэтому используются поля Animal.
//значение this – это текущий объект (longEar). Это важно: для всех методов объекта this указывает на текущий объект, а не на прототип или что-то ещё.
//само существование [[HomeObject]] нарушает этот принцип, так как методы запоминают свои объекты. [[HomeObject]] нельзя изменить, эта связь – навсегда.

//Единственное место в языке, где используется [[HomeObject]] – это super.
