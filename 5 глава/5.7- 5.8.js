//Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.
/*new Map() – создаёт коллекцию.
map.set(key, value) – записывает по ключу key значение value.
map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
map.clear() – очищает коллекцию от всех элементов.
map.size – возвращает текущее количество элементов.
*/
let map = new Map();
map.set('1', 'str1'); // строка в качестве ключа
map.set(1, 'mun1'); //цифра как ключ
map.set(true, 'bool1'); // булево значение как ключ
// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
console.log(map.get(1)); //mun1
console.log(map.get('1')); //str1
console.log(map.size); //3
//Как мы видим, в отличие от объектов, ключи не были приведены к строкам. Можно использовать любые типы данных для ключей.
//Хотя map[key] также работает, например, мы можем установить map[key] = 2, в этом случаеmap рассматривался бы как обычный JavaScript объект, таким образом это ведёт ко всем соответствующим ограничениям (только строки/символьные ключи и так далее).
//Map может использовать объекты в качестве ключей.

let john = { name: 'John' };
let visitCountMap = new Map();
// давайте сохраним количество посещений для каждого пользователя
visitCountMap.set(john, 123);
// объект john - это ключ для значения в объекте Map
alert(visitsCountMap.get(john)); // 123
//Использование объектов в качестве ключей – одна из наиболее заметных и важных функций Map. Это то что невозможно для Object.
{
	//Давайте попробуем заменить Map на Object:
	let john = { name: 'John' };
	let ben = { name: 'Ben' };
	let visitsCountObj = {};
	visitsCountObj[ben] = 234;
	visitsCountObj[john] = 123;
	//Так как visitsCountObj является объектом, он преобразует все ключи Object, такие как john и ben, в одну и ту же строку "[object Object]". Это определенно не то, чего мы хотим.
}
//Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку:

map.set('1', 'str').set(1, 'num1').set(true, 'bool1');
/*Для перебора коллекции Map есть 3 метода:

map.keys() – возвращает итерируемый объект по ключам,
map.values() – возвращает итерируемый объект по значениям,
map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of*/

let recipeMap = new Map([
	['огурец', 500],
	['помидор', 350],
	['лук', 50],
]);
// перебор по ключам (овощи)
for (let vegetable of recipeMap.keys()) {
	console.log(vegetable);
}
/*recipeMap.keys():

Возвращает итератор по ключам Map.

В данном случае ключи — это строки: 'огурец', 'помидор', 'лук'.

for...of:

Цикл проходит по каждому ключу из итератора.

На каждой итерации переменная vegetable принимает значение текущего ключа.

console.log(vegetable):// огурец, помидор, лук

*/
for (let amount of recipeMap.values()) {
	console.log(amount); // 500, 350, 50
}
for (let entry of recipeMap) {
	console.log(entry); // // то же самое, что и recipeMap.entries()
}
// огурец,500
//В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов

// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
	console.log(`${key} : ${value}`);
});
/*Порядок аргументов фиксирован:

Первый аргумент всегда значение.

Второй аргумент всегда ключ.

Третий аргумент всегда сам Map.

*/
//При создании Map мы можем указать массив (или другой итерируемый объект) с парами ключ-значение для инициализации, как здесь:
// массив пар [ключ, значение]

let map1 = new Map([
	['1', 'str1'],
	[1, 'num1'],
	[true, 'bool1'],
]);
console.log(map.get('1')); // str1
//Если у нас уже есть обычный объект, и мы хотели бы создать Map из него, то поможет встроенный метод Object.entries(obj), который получает объект и возвращает массив пар ключ-значение для него, как раз в этом формате.
//Так что мы можем создать Map из обычного объекта следующим образом
{
	let obj = {
		name: 'Jonh',
		age: 30,
	};
	let map = new Map(Object.entries(obj));
	console.log(map.get('name')); // John
}
//Статический Object.entries()метод возвращает массив собственных перечислимых пар ключ-значение строкового свойства заданного объекта.
/*
Здесь Object.entries возвращает массив пар ключ-значение: [ ["name","John"], ["age", 30] ]. Это именно то, что нужно для создания Map. Когда использовать Object.entries?
Если у вас уже есть объект, и вы хотите быстро преобразовать его в Map.

Если объект большой, и вы не хотите вручную добавлять каждый элемент*/
//Object.fromEntries, который делает противоположное: получив массив пар вида [ключ, значение], он создаёт из них объект:

let prices = Object.fromEntries([
	['banana', 1],
	['orange', 2],
	['meat', 4],
]);
// prices = { banana: 1, orange: 2, meat: 4 }
console.log(prices.orange); // 2

{
	let map = new Map();
	map.set('banana', 1);
	map.set('orange', 2);
	map.set('meat', 4);
	let obj = Object.fromEntries(map.entries);
} //[ ['banana', 1], ['orange', 2], ['meat', 4] ]
//Object.fromEntries():

//Этот метод принимает массив (или итератор) пар "ключ-значение" и создает из них обычный объект.
{
	//'banana': 1,
	//'orange': 2,
	//'meat': 4,
}
//Вызов map.entries() возвращает итерируемый объект пар ключ/значение, как раз в нужном формате для Object.fromEntries.

//let obj1 = Object.fromEntries(map)// убрать .entries()
//Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
/*new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
set.clear() – удаляет все имеющиеся значения.
set.size – возвращает количество элементов в множестве.
Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз*/
{
	let set = new Set();
	let john = {
		name: 'John',
	};
	let pete = {
		name: 'Pete',
	};
	let mary = { name: 'Mary' };
	set.add(john);
	set.add(pete);
	set.add(mary);
	set.add(john);
	set.add(mary);
	// set хранит только 3 уникальных значения
	console.log(set.size); //3
	for (let user of set) {
		console.log(user.name); //JohnJohn;
	}
}
//Метод map.entries() возвращает итератор по парам [ключ, значение].

//Однако сам Map уже является итерируемым объектом, где каждый элемент — это пара [ключ, значение].
//recipeMap.keys() возвращает итератор, который нельзя напрямую отобразить в alert.

//Чтобы увидеть ключи, нужно либо перебрать итератор с помощью цикла, либо преобразовать его в массив с помощью Array.from или оператора расширения (...).
function unique(arr) {
	let noDubles = new Set(arr);
	return Array.from(noDubles);
}
let values = [
	'Hare',
	'Krishna',
	'Hare',
	'Krishna',
	'Krishna',
	'Krishna',
	'Hare',
	'Hare',
	':-O',
];

console.log(unique(values));

function aclean(arr) {
	let map = new Map();
	for (let word of arr) {
		// разбиваем слово на буквы, сортируем и объединяем снова в строку
		let sorted = word.toLowerCase().split('').sort().join('');
		map.set(sorted, word);
		return Array.from(map.values);
	}
}
let arr = ['nap', 'teachers', 'cheaters', 'PAN', 'ear', 'era', 'hectares'];
console.log(aclean(arr));
//В конце Array.from(map.values()) принимает итерируемый объект значений объекта Map (в данном случае нам не нужны ключи) и возвращает их в виде массива.
//Если мы когда-либо ещё встретим слово в той же отсортированной форме, тогда это слово перезапишет значение с тем же ключом в объекте. Таким образом, нескольким словам у нас будет всегда соответствовать одна отсортированная форма.

arr1 = [1, 1, 1, 2, 2, 2, 3, 3, 34, 4, 4];
arr2 = arr1.reduce(
	(acc, elem, index, array) => {
		let lsdtIn = array.lastIndexOf(elem);
		let firstIn = array.indexOf(elem);
		if (lsdtIn === firstIn) {
			acc[0].push(elem);
		} else {
			acc[1].push(elem);
		}
		return acc;
	},
	[[], []]
);
console.log(arr2);
{
	function aclean(arr) {
		let obj = {};
		for (let word of arr) {
			let sorted = arr[i].toLowerCase().split('').sort().join('');
			obj[sorted] = arr[i];
		}
		return Object.values(obj);
	}
}

{
	let map = new Map();
	map.set('name', 'john');
	let keys = Arrays.from(map.keys());
	// Error: keys.push is not a function
	// Ошибка: keys.push -- это не функция
	keys.push('more');
}

let john1 = {
	name: 'john',
	/// объект доступен, переменная john1 — это ссылка на него

	// перепишем ссылку
};
john1 = null;
// объект будет удалён из памяти
//Например, если мы поместим объект в массив, то до тех пор, пока массив существует, объект также будет существовать в памяти, несмотря на то, что других ссылок на него нет.
{
	let john = { name: 'John' };

	let array = [john];
	john = null; // перезаписываем ссылку на объект

	// объект john хранится в массиве, поэтому он не будет удалён сборщиком мусора
	// мы можем взять его значение как array[0]
	console.log(array);
}
//Аналогично, если мы используем объект как ключ в Map, то до тех пор, пока существует Map, также будет существовать и этот объект. Он занимает место в памяти и не может быть удалён сборщиком мусора
{
	let john = {
		name: 'John',
	};
	let map = new Map();
	map.set(john, '...');
	john = null; // перезаписываем ссылку на объект
	console.log(map);

	// объект john сохранён внутри объекта `Map`,
	// он доступен через map.keys()
}
//WeakMap – принципиально другая структура в этом аспекте. Она не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.
//Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:

let weakMap = new WweakMap();
let obj = {};
weakmap.set(obj, 'ok'); // работает (объект в качестве ключа)
// нельзя использовать строку в качестве ключа
weakMap.set('test', 'Whoops'); // Ошибка, потому что "test" не объект
//Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.

{
	let yt = {
		name: 'lkl',
	};
	let weakmap = new WeakMap();
	weakmap.set(yt, '...');
	yt = null;
}
// перезаписываем ссылку на объект

// объект john удалён из памяти!

//WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из неё.
/*В WeakMap присутствуют только следующие методы:

weakMap.get(key)
weakMap.set(key, value)
weakMap.delete(key)
weakMap.has(key)
В основном, WeakMap используется в качестве дополнительного хранилища данных.

Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке, и хотим сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, то WeakMap – как раз то, что нужно.

Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут
*/
//К чему такие ограничения? Из-за особенностей технической реализации. Если объект станет недостижим (как объект john в примере выше), то он будет автоматически удалён сборщиком мусора. Но нет информации, в какой момент произойдёт эта очистка.
weakmap.set(john, 'секретные документы');
//Вот пример реализации счётчика посещений с использованием Map:
// 📁 visitsCount.js
let visitsCount = new Map(); // map: пользователь => число визитов
function countUser(user) {
	let count = visitCountMap.get(user) || 0;
	visitsCountMap.set(user, count + 1);
}
// 📁 main.js
let anna = {
	name: ' Anna',
};
countUser(anna);
// ведём подсчёт посещений

// пользователь покинул нас
anna = null;
/*Теперь объект john должен быть удалён сборщиком мусора, но он продолжает оставаться в памяти, так как является ключом в visitsCountMap.

Нам нужно очищать visitsCountMap при удалении объекта пользователя, иначе коллекция будет бесконечно расти. Подобная очистка может быть неудобна в реализации при сложной архитектуре приложения.

Проблемы можно избежать, если использовать WeakMap:*/

{
	let visitsCountMap = new WeakMap();
	// map: пользователь => число визитов
	function countUser(user) {
		let count = visitsCountMap.get(user) || 0;
		visitsCountMap.set(user, count + 1);
	}
}
//Теперь нет необходимости вручную очищать visitsCountMap. После того, как объект john стал недостижим другими способами, кроме как через WeakMap, он удаляется из памяти вместе с информацией по такому ключу из WeakMap.
//Другая частая сфера применения – это кеширование, когда результат вызова функции должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый результат, повторно используя его.

let cashe = new Map();
// вычисляем и запоминаем результат
function process(obj) {
	if (!cashe.has(obj)) {
		let result;
		/* = тут какие-то вычисления результата для объекта */
		cashe.set(obj, result);
	}
	return cache.get(obj);
}
// Теперь используем process() в другом файле:
// 📁 main.js
let obj2 = {
	/* допустим, у нас есть какой-то объект */
};

let result1 = process(obj);
// вычислен результат
// ...позже, из другого места в коде...
let result2 = process(obj);
// ...позже, когда объект больше не нужен:
obj = null;
console.log(cashe.size);
//Но если мы будем использовать WeakMap вместо Map, то эта проблема исчезнет: закешированные результаты будут автоматически удалены из памяти сборщиком мусора.

{
	let cashe = new WeakMap();
	function process(obj) {
		if (!cashe.has(obj)) {
			let result;
			cashe.set(obj, result);
		}
		return cashe.get(obj);
	}
	let obj = {
		/* какой-то объект */
	};

	let result1 = process(obj);
	let result2 = process(obj);

	// ...позже, когда объект больше не нужен:
	obj = null;

	// Нет возможности получить cache.size, так как это WeakMap,
	// но он равен 0 или скоро будет равен 0
	// Когда сборщик мусора удаляет obj, связанные с ним данные из кеша тоже удаляются
}
//Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
//Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
//Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.
//Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё содержимое. Это может доставлять неудобства, но не мешает WeakMap/WeakSet выполнять их главную задачу – быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде
{
	let visitedSet = new WeakSet();
	let john = { name: 'John' };
	let pete = { name: 'Pete' };
	let mary = { name: 'Mary' };
	visitedSet.add(john); // John заходил к нам
	visitedSet.add(pete); // потом Pete
	visitedSet.add(john); // John снова
	// visitedSet сейчас содержит двух пользователей
	console.log(visitedSet.has(john)); // true

	// проверим, заходила ли Mary?
	alert(visitedSet.has(mary)); // false
	john = null;
	// структура данных visitedSet будет очищена автоматически (объект john будет удалён из visitedSet)
}
let messages = [
	{ text: 'Hello', from: 'John' },
	{ text: 'How goes?', from: 'John' },
	{ text: 'See you soon', from: 'Alice' },
];
let readMessages = new WeakSet();
// Два сообщения были прочитаны
readMessages.add(messages[0]);
readMessages.add(messages[1]);
// readMessages содержит 2 элемента

// ...давайте снова прочитаем первое сообщение!
readMessages.add(messages[0]);
// readMessages до сих пор содержит 2 элемента

// Вопрос: было ли сообщение message[0] прочитано?
console.log('Read message 0:' + readMessages.has(messages[0]));
messages.shift();
// теперь readMessages содержит 1 элемент (хотя технически память может быть очищена позже)
let readMap = new WeakMap();
readMap.set(messages[0]), new Date(2017, 1, 1);
