let arr = new Array();
let arr1 = [];
let fruits = ['Яблоко', 'Апельсин', 'Слива'];
//Элементы массива нумеруются, начиная с нуля.
//Мы можем получить элемент, указав его номер в квадратных скобках:

console.log(fruits[0]); // Яблоко
console.log(fruits[1]); // Апельсин
console.log(fruits[2]); // Слива
//Мы можем заменить элемент:
fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]
//Или добавить новый к существующему массиву
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
//Общее число элементов массива содержится в его свойстве length
let fruits1 = ['Яблоко', 'Апельсин', 'Слива'];
console.log(fruits1.length); //3
console.log(fruits1); // Яблоко, Апельсин, Слива
//в массиве могут храниться элементы любого типа.

// разные типы значений
let arr2 = [
	'Яблоко',
	{ name: 'Джон' },
	true,
	function () {
		alert('привет');
	},
];
arr2[3](); // привет
//Список элементов массива, как и список свойств объекта, может оканчиваться запятой:
/*let fruits = [
  "Яблоко",
  "Апельсин",
  "Слива",
];
*/
//Висячая запятая» упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными.
//Мы можем явно вычислить индекс последнего элемента, а затем получить к нему доступ вот так: fruits[fruits.length - 1].

let fruits2 = ['Apple', 'Orange', 'Plum'];
console.log(fruits2[fruits2.length - 1]);
//Plum
//К счастью, есть более короткий синтаксис: fruits.at(-1):
console.log(fruits.at(-1)); // Plum
/*Другими словами, arr.at(i):

это ровно то же самое, что и arr[i], если i >= 0.
для отрицательных значений i, он отступает от конца массива.
*/
//Очередь – один из самых распространённых вариантов применения массива. В области компьютерных наук так называется упорядоченная коллекция элементов, поддерживающая два вида операций:
//push добавляет элемент в конец.
//shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.
/*Существует и другой вариант применения для массивов – структура данных, называемая стек.

Она поддерживает два вида операций:

push добавляет элемент в конец.
pop удаляет последний элемент.
*/
//Примером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху:
//Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива.
/*pop
Удаляет последний элемент из массива и возвращает его:

let fr = ["Яблоко", "Апельсин", "Груша"];
console.log(fr.pop());// удаляем "Груша" и выводим его
alert( fruits ); // Яблоко, Апельсин
push
Добавляет элемент в конец массива:

let fr = ["Яблоко", "Апельсин"]
fr.push("Груша");
alert( fr );// Яблоко, Апельсин, Груша
// fruits[fruits.length] = "Груша" добавляет элемент "Груша" на позицию с индексом 2 (то есть в конец массива).
fruits.push(...) равнозначно fruits[fruits.length] = ...?
shift
Удаляет из массива первый элемент и возвращает его:
let fr1 = ["Яблоко", "Апельсин", "Груша"];
alert(fr1.shift())// удаляем Яблоко и выводим его
alert(fr1)
/// Апельсин, Груша
unshift
Добавляет элемент в начало массива:

let fr2 = ["Апельсин", "Груша"];
console.log(fr2.unshift('Яблоко')); /// выводит 3 элемент index
console.log(fr2)
*/
let fr2 = ['Апельсин', 'Груша'];
fr2.unshift('Яблоко');
console.log(fr2); // Яблоко, Апельсин, Груша
//Методы push и unshift могут добавлять сразу несколько элементов:

let fr3 = ['Яблоко'];
fr3.push('Апельсин', 'Груша');
fr3.unshift('Ананас', 'Лимон');
console.log(fr3); // ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
//Квадратные скобки, используемые для того, чтобы получить доступ к свойству arr[0] – это по сути обычный синтаксис доступа по ключу, как obj[key], где в роли obj у нас arr, а в качестве ключа – числовой индекс.
//Массив копируется по ссылке:
let fr4 = ['Банан'];
let arr4 = fr4; // копируется по ссылке (две переменные ссылаются на один и тот же массив
console.log(fr4 === arr4); // true

arr4.push('Груша'); // массив меняется по ссылке
console.log(fr4);
// Банан, Груша - теперь два элемента
//Методы push/pop выполняются быстро, а методы shift/unshift – медленно.
/*Просто взять и удалить элемент с номером 0 недостаточно. Нужно также заново пронумеровать остальные элементы.

Операция shift должна выполнить 3 действия:

Удалить элемент с индексом 0.
Сдвинуть все элементы влево, заново пронумеровать их, заменив 1 на 0, 2 на 1 и т.д.
Обновить свойство length .
*/
//Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:

let arr5 = ['Яблоко', 'Апельсин', 'Груша'];
for (let i = 0; i < arr5.length; i++) {
	console.log(arr5[i]);
}
//Но для массивов возможен и другой вариант цикла, for..of:

let ar6 = ['Яблоко', 'Апельсин', 'Слива'];
// проходит по значениям
for (let key of ar6) {
	console.log(key);
}
//Цикл for..of не предоставляет доступа к номеру текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче.

//технически, так как массив является объектом, можно использовать и вариант for..in:

let arr7 = ['Яблоко', 'Апельсин', 'Груша'];

for (let key in arr7) {
	alert(arr7[key]); // Яблоко, Апельсин, Груша
}
//Цикл for..in выполняет перебор всех свойств объекта, а не только цифровых
//Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее
//В общем, не следует использовать цикл for..in для массивов.
//Свойство length автоматически обновляется при изменении массива
//Свойство length автоматически обновляется при изменении массива
//Например, единственный элемент, имеющий большой индекс, даёт большую длину:

let fr7 = [];
fr7[123] = 'Яблоко';
console.log(fr7.length); //124

let ar8 = [1, 2, 3, 4, 5];
ar8.length = 2; //укорачиваем до двух элементов
console.log(ar8); // [1, 2]
ar8.length = 5; // возвращаем length как было
console.log(ar8[3]); // undefined: значения не восстановились
//Таким образом, самый простой способ очистить массив – это arr.length = 0;.

let ar9 = new Array('Яблоко', 'Груша', 'и тд');
//Если new Array вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов, но с заданной длиной.

let a8 = new Array(2);
console.log(a8[0]); // undefined! нет элементов
console.log(a8.length);
// length 2
//Как мы видим, в коде, представленном выше, в new Array(number) все элементы равны undefined.
//Массивы могут содержать элементы, которые тоже являются массивами. Это можно использовать для создания многомерных массивов, например, для хранения матриц:

let matrix = [
	[1, 2, 3],
	[4, 5, 6],
	[7, 8, 9],
];
console.log(matrix[1][1]); // 5, центральный элемент

console.log(matrix[0][0]); //1
//Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.

let a4 = [1, 2, 3];
alert(a4); // 1,2,3
console.log(String(a4) === '1,2,3');
alert([] + 1); // "1"
alert([1] + 1); //11
alert([1, 2] + 1); // "1,21"
console.log([1, 2] + 1); //1,21
//Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString, таким образом, здесь [] становится пустой строкой, [1] становится "1", а [1,2] становится "1,2".
//Когда бинарный оператор плюс "+" добавляет что-либо к строке, он тоже преобразует это в строку, таким образом:
alert('' + 1); // "1"
alert('1' + 1); // "11"
alert('1,2' + 1); // "1,21"
//Итак, если мы всё же сравниваем массивы с помощью ==, то они никогда не будут одинаковыми, если только мы не сравним две переменные, которые ссылаются на один и тот же массив
console.log([] == []); // false
console.log([0] == [0]); // false
alert(0 == []); // true

alert('0' == []); // false
//Здесь, в обоих случаях, мы сравниваем примитив с объектом массива. Таким образом, массив [] преобразуется в примитив с целью сравнения и становится пустой строкой ''.
// после того, как [] был преобразован в ''
alert(0 == ''); // true, так как '' преобразуется в число 0

alert('0' == ''); // false, нет преобразования типов, разные строки
/*Сравнение строк происходит побайтово (посимвольно), и строки считаются равными только тогда, когда они идентичны по длине и содержанию.

В данном случае:

'0' имеет длину 1.

'' имеет длину 0.

*/
//Чтобы пройтись по элементам массива:

//for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
