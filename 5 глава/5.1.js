let str = 'Привет';
console.log(str.toUpperCase()); //ПРИВЕТ
/*Строка str – примитив. В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы, как toUpperCase().
Этот метод запускается и возвращает новую строку (показывается в alert).
Специальный объект удаляется, оставляя только примитив str.
*/
let num = 1.23456;
console.log(num.toFixed(2)); //1.23
/*Особенные примитивы null и undefined являются исключениями. У них нет соответствующих «объектов-обёрток», и они не имеют никаких методов. В некотором смысле, они «самые примитивные».

Попытка доступа к свойствам такого значения возвратит ошибку:

alert(null.test); // ошибка

let str1 = 'Привет'

str1.test = 5

console.log(str1.test)
undefined (без strict)
Ошибка (strict mode)
В момент обращения к свойству str создаётся «объект-обёртка».
В строгом режиме, попытка изменения этого объекта выдаёт ошибку.
Без строгого режима, операция продолжается, объект получает свойство test, но после этого он удаляется, так что на последней линии str больше не имеет свойства test.
*/
let billion = 1000000000;
let billion1 = 1_000_000_000; //Символ нижнего подчёркивания _ – это «синтаксический сахар», он делает число более читабельным.
let billion2 = 1e9; // 1 миллиард, буквально: 1 и 9 нулей
alert(7.3e9); // 7.3 миллиарда (7,300,000,000)
//Другими словами, "e" умножает число на 1 с указанным количеством нулей.

1e3 === 1 * 1000; // e3 означает *1000

1.23e6 === 1.23 * 1000000; // e6 означает *100000
//Другими словами, "e" умножает число на 1 с указанным количеством нулей

let mcs = 0.000001; //А сейчас давайте запишем что-нибудь очень маленькое. К примеру, 1 микросекунду (одна миллионная секунды):
let ms = 1e-6; //шесть нулей слева от 1
//Другими словами, отрицательное число после "e" подразумевает деление на 1 с указанным количеством нулей:

////alert(1e-3 === 1 / 1000) //(=0.001)
// 1 делится на 1 с 3 нулями
//alert(1.23e-6 = 1.23) / 1000000 //(=0.00000123)
// 1.23 делится на 1 с 6 нулями
//Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. Естественно, есть короткий стиль записи: 0x, после которого указывается число.

alert(0xff); // 255
alert(0xff); //// 255 (то же самое, регистр не имеет значения)
//Двоичные и восьмеричные числа используются не так часто, но они также поддерживаются: 0b для двоичных и 0o для восьмеричных:

let a = 0b11111111; // двоичная (бинарная) форма записи числа 255'
let b = 0o377; // восьмеричная форма записи числа 255

alert(a == b); // true, с двух сторон число 255
//Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.

let num2 = 255;
console.log(num2.toString(16)); // ff
console.log(num2.toString(2)); //11111111

//base может варьироваться от 2 до 36 (по умолчанию 10).

//base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F.
//ase=2 — обычно используется для отладки побитовых операций, цифры 0 или 1

//base=36 — максимальное основание, цифры могут быть 0..9 или A..Z. То есть, используется весь латинский алфавит для представления числа. Забавно, но можно использовать 36-разрядную систему счисления для получения короткого представления большого числового идентификатора. К примеру, для создания короткой ссылки. Для этого просто преобразуем его в 36-разрядную систему счисления:

alert((123456).toString(36)); // 2n9c

//Внимание! Две точки в 123456..toString(36) это не опечатка. Если нам надо вызвать метод непосредственно на числе, как toString в примере выше, то нам надо поставить две точки .. после числа.

//Если мы поставим одну точку: 123456.toString(36), тогда это будет ошибкой, поскольку синтаксис JavaScript предполагает, что после первой точки начинается десятичная часть. А если поставить две точки, то JavaScript понимает, что десятичная часть отсутствует, и начинается метод.
//Также можно записать как (123456).toString(36).

/*Math.floor
Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.

Math.ceil
Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.

Math.round
Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.

Math.trunc (не поддерживается в Internet Explorer)
Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
*/
let num3 = 1.23456;
console.log(Math.round(num * 100) / 100);

// 1.23456 -> 123.456 -> 123 -> 1.23

//Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.

let num4 = 12.34;
console.log(num4.toFixed(1)); // "12.3"
//Обратите внимание, что результатом toFixed является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:

let num5 = 12.34;
console.log(num5.toFixed(5));
// "12.34000", добавлены нули, чтобы получить 5 знаков после запятой
//Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(), пример с унарным оператором: +num.toFixed(5).

//Внутри JavaScript число представлено в виде 64-битного формата IEEE-754. Для хранения числа используется 64 бита: 52 из них используется для хранения цифр, 11 для хранения положения десятичной точки и один бит отведён на хранение знака.

//Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:
alert((0.1).toString(2)); // 0.0001100110011001100110011001100110011001100110011001101
alert(1e500); // Infinity
alert(0.1 + 0.2 == 0.3); // false
let sum = 0.1 + 0.2;
alert(0.1 + 0.2); // 0.30000000000000004
//Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.
alert(sum.toFixed(2)); // "0.30"

let sum1 = 0.1 + 0.2;
console.log(+sum.toFixed(2)); // 0.3

//Также можно временно умножить число на 100 (или на большее), чтобы привести его к целому, выполнить математические действия, а после разделить обратно. Суммируя целые числа, мы уменьшаем погрешность, но она всё равно появляется при финальном делении:
console.log((0.1 * 10 + 0.2 * 10) / 10); // 0.3
console.log((0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
//Таким образом, метод умножения/деления уменьшает погрешность, но полностью её не решает
//Infinity (и -Infinity) — особенное численное значение, которое ведёт себя в точности как математическая бесконечность ∞.
//NaN представляет ошибку.

//Эти числовые значения принадлежат типу number, но они не являются «обычными» числами, поэтому есть функции для их проверки:

//isNaN(value) преобразует значение в число и проверяет является ли оно NaN:

alert(isNan(NaN)); //// true
alert(isNan('str')); /// true
alert(NaN === NaN); // false
//isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е.не NaN / Infinity / -Infinity:
alert(isFinite('15')); // true
alert(isFinite('str')); //false
alert(isFinite(true)); // true
alert(isFinite(Infinity)); //false
let num6 = +prompt('Введите число:', '');

//// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
alert(isFinite(num6));
//Помните, что пустая строка интерпретируется как 0 во всех числовых функциях, включаяisFinite.

//Number.isNaN(value) возвращает true только в том случае, если аргумент принадлежит к типу number и является NaN. Во всех остальных случаях возвращает false.

//isNaN() сначала пытается превратить значение в число, а потом проверяет, NaN ли оно.

//Number.isNaN() не пытается ничего превращать — он проверяет только точно NaN.
alert(Number.isNaN('str' / 2)); // true
alert(Number.isNaN('str')); // false, так как "str" является строкой, а не числом
alert(isNaN('str')); // true, так как isNaN сначала преобразует строку "str" в число и в результате преобразования получает NaN
//Number.isFinite(value) возвращает true только в том случае, если аргумент принадлежит к типу number и не является NaN/Infinity/-Infinity. Во всех остальных случаях возвращает false.
alert(Number.isFinite(123)); // true
alert(Number.isFinite(Infinity)); // false
alert(Number.isFinite(2 / 0)); // false
alert(Number.isFinite('123')); // false, так как "123" является строкой, а не числом
alert(isFinite('123')); // true, так как isFinite сначала преобразует строку "123" в число 123
//Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, он использует Object.is
Object.is(Nan, Nan) === true, Object.is(0, -0) === false;
/*Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:

alert( +"100px" ); // NaN
Единственное исключение — это пробелы в начале строки и в конце, они игнорируются parseInt и parseFloat.

Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой*/
alert(parseInt('100px')); //100
alert(parseFloat('12.5em')); //12.5
alert(parseInt('12.3')); //12 вернётся только целая часть
alert(parseFloat('12.3.4')); //12.3произойдёт остановка чтения на второй точке

//Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:
alert(parseInt('f123')); //NaN, на первом символе происходит остановка чтения
//Если она встречает символ, который не может быть частью числа (например, буква или пробел), она останавливается и возвращает то, что успела прочитать до этого момента
//Поскольку первый символ не может быть частью числа, parseInt() сразу останавливается и возвращает NaN.
//Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

alert(parseInt('0xff', 16)); // 255
alert(parseInt('ff', 16)); // 255, без 0x тоже работает
alert(parseInt('2n9c', 36)); // 123456
//В JavaScript встроен объект Math, который содержит различные математические функции и константы.
alert(Math.random()); // 0.1234567894322
alert(Math.random()); // ... (любое количество псевдослучайных чисел)
//Math.max(a, b, c...) / Math.min(a, b, c...)
//Возвращает наибольшее/наименьшее число из перечисленных аргументов.
alert(Math.max(3, 5, -10, 0, 1)); //5
alert(Math.min(1, 2)); // 1
//Math.pow(n, power)
//Возвращает число n, возведённое в степень power
alert(Math.pow(2, 10)); /// 2 в степени 10 = 1024

/*
function ir() {
  for (let i = 0; i < 5; i++) {
    let str = prompt('str', '0');
    if (str === 'aa') {
      console.log('password is correct');
      break;
    } else if (str === '' ||str ===  null) {
      console.log('u closed me');
      break;
    } else {
      console.log('password is wrong');
    }
  }
}
ir();
Пользователь нажимает "Отмена" (Cancel) или Esc:

В этом случае prompt возвращает null.

Пользователь нажимает "ОК" (OK) без ввода текста:

В этом случае prompt возвращает пустую строку "".

'use strict'
let object = {
    f: function () {
        console.log(this);
    },
    r: this
}
object.f(); //object
console.log(object.r); //window

function func() {
    console.log(this); //undefined
}
func();
*/
console.log(Math.trunc(1.5));
console.log(Math.trunc(1.6));
console.log(Math.round(1.6));
//Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // списокгостей
//Многострочные строки также можно создавать с помощью одинарных и двойных кавычек, используя так называемый «символ перевода строки», который записывается как \n
let guestList1 = 'Guests:\n * John\n * Pete\n * Mary';
console.log(guestList1);

//В частности, эти две строки эквивалентны, просто записаны по-разному:

let str1 = 'Hello\nUs';
let str2 = `Hello
Us`;
console.log(str1 == str2); // true
/*\n	Перевод строки
\r	В текстовых файлах Windows для перевода строки используется комбинация символов \r\n, а на других ОС это просто \n. Это так по историческим причинам, ПО под Windows обычно понимает и просто \n.
\', \", \`	Кавычки
\\	Обратный слеш
\t	Знак табуляции
\b, \f, \v	Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются.
Как вы можете видеть, все спецсимволы начинаются с обратного слеша, \ — так называемого «символа экранирования».

Он также используется, если необходимо вставить в строку кавычку*/
//console.log("I\'m the human")
//Но что, если нам надо добавить в строку собственно сам обратный слеш \?

//Это можно сделать, добавив перед ним… ещё один обратный слеш!
alert('The backlash \\');
//Свойство length содержит длину строки:
alert('my\n'.length);
//Обратите внимание, \n — это один спецсимвол, поэтому тут всё правильно: длина строки 3.
//Так как str.length — это числовое свойство, а не функция, добавлят скобки не нужно.
//Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos].
let str3 = 'hello';
// получаем первый символ
console.log(str3[0]); //h
console.log(str3.at(0)); //h
// получаем последний символ
console.log(str3[str3.length - 1]); //o
console.log(str3.at(-1)); //o
//Таким образом, .at(-1) означает последний символ, а .at(-2) – тот, что перед ним, и т.д.
//Квадратные скобки всегда возвращают undefined для отрицательных индексов. Например:

let str4 = 'Hello';
console.log(str4[-2]); // undefined
console.log(str4.at(-2)); //l
/*Метод at() позволяет использовать отрицательные индексы.

Отрицательные индексы отсчитываются с конца строки:

-1 — последний символ.

-2 — предпоследний символ.

*/
//Также можно перебрать строку посимвольно, используя for..of:
for (let char of 'Hello') {
	console.log(char);
} // // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т.д.)
//Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.

let st = 'Hi';
st[0] = 'h'; //ошибка
alert(st[0]); // не работает
//Можно создать новую строку и записать её в ту же самую переменную вместо старой.
let str5 = 'Hi';
str5 = 'h' + str5[1]; // заменяем строку
console.log(str5);
//Методы toLowerCase() и toUpperCase() меняют регистр символов
//Если мы захотим перевести в нижний регистр какой-то конкретный символ:
console.log('Internet'[0].toLowerCase()); //i
console.log('Inter'.toUpperCase());
console.log('Inter'.toLowerCase());
/*Первый метод — str.indexOf(substr, pos).

Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений.
Подстрока — это часть строки

*/

let list = 'Widget with id';
console.log(list.indexOf('Widget')); //// 0, потому что подстрока 'Widget' найдена в начале
console.log(list.indexOf('widget')); // // -1, совпадений нет, поиск чувствителен к регистру
console.log(list.indexOf('id')); // // 1, Первый раз на позиции 1 (в слове "Widget")подстрока "id" найдена на позиции 1 (..idget with id)
console.log(list.length);
console.log(list.indexOf('id', 2)); //12
//Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле

let text = 'Ослик Иа-Иа посмотрел на виадук';
let target = 'Иа'; // цель поиска
let pos = 0; // начальная позиция поиска
while (true) {
	let foundPos = text.indexOf(target, pos); //ищет подстроку target в строке text, начиная с позиции pos.
	if (foundPos == -1) break;

	alert(`Найдено тут:  ${foundPos}`);

	pos = foundPos + 1; // продолжаем со следующей позиции
} // 6; 9

let text1 = 'Ослик Иа-Иа посмотрел на виадук';
let target1 = 'Иа';
let pos1 = -1;
while ((pos = text1.indexOf(target1, pos1 + 1)) != -1) {
	console.log(pos);
}

let tex = 'Widget with id';
if (tex.indexOf('Widget') != -1) {
	console.log('Совпадение есть'); // теперь работает
}
/*При проверке indexOf в условии if есть небольшое неудобство. Такое условие не будет работать:

let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("Совпадение есть"); // не работает
}
Мы ищем подстроку "Widget", и она здесь есть, прямо на позиции 0. Но alert не показывается, т. к. str.indexOf("Widget") возвращает 0, и if решает, что тест не пройден.

/~Он преобразует число в 32-разрядное целое со знаком (signed 32-bit integer). Дробная часть, в случае, если она присутствует, отбрасывается. Затем все биты числа инвертируются.

На практике это означает простую вещь: для 32-разрядных целых чисел значение ~n равно -(n+1)*/
alert(~2); // -3, то же, что -(2+1)
alert(~1); // -2, то же, что -(1+1)
alert(~0); // -1, то же, что -(0+1)
alert(~-1); // 0, то же, что -(-1+1)
//Таким образом, ~n равняется 0 только при n == -1 (для любого n, входящего в 32-разрядные целые числа со знаком).
//Если подстрока не найдена, то ~str.indexOf("...") вернет 0, и условие if не выполнится.
//Если подстрока найдена, то ~str.indexOf("...") вернет не нулевое значение, и условие if выполнится.
let te = 'Widget';
if (~str.indexOf('Widget')) {
	alert('Совпадение есть'); // работает
}
//Просто запомните: if (~str.indexOf(…)) означает «если найдено
//Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.

alert('Widget with id'.includes('Widget')); //true
alert('Hello'.includes('Bye')); // false
//Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:

alert('Midget'.includes('id')); //true
alert('Midget'.includes('id', 3)); // false, поиск начат с позиции 3
//Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

alert('Widget'.startsWith('Wid')); // true, "Wid" — начало "Widget"
alert('Widget'.endsWith('get')); /// true, "get" — окончание "Widget
//В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.
//str.slice(start [, end])
//Возвращает часть строки от start до (не включая) end.
let str7 = 'stringify';
// 'strin', символы от 0 до 5 (не включая 5)
alert(str7.slice(0, 5));
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert(str7.slice(0.1));
//Если аргумент end отсутствует, slice возвращает символы до конца строки:

let str8 = 'stringify';
alert(str.slice(2)); // ringify, с позиции 2 и до конца
//Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:

let str9 = 'stringify';
alert(str9.slice(-4, -1)); //gif
// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
//str.substring(start [, end])
//Возвращает часть строки между start и end (не включая) end.
//Это — почти то же, что и slice, но можно задавать start больше end.
//Если start больше end, то метод substring сработает так, как если бы аргументы были поменяны местами.
let st2 = 'stringify';
// для substring эти два примера — одинаковы
alert(st2.substring(2, 6)); // "ring"
alert(st2.substring(6, 2)); // "ring"
//Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0
/*str.substr(start [, length])
Возвращает часть строки от start длины length.

В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:*/

let st4 = 'stringify';
// ring, получаем 4 символа, начиная с позиции 2
alert(st4.substr(2, 4));
//Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:
let st5 = 'stringify';
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert(str.substr(-4, 2));
/*Давайте подытожим, как работают эти методы, чтобы не запутаться:

метод	выбирает…	отрицательные значения
slice(start, end)	от start до end (не включая end)	можно передавать отрицательные значения
substring(start, end)	между start и end (не включая end)	отрицательные значения равнозначны 0
substr(start, length)	length символов, начиная от start	значение start может быть отрицательным*/
//Как мы знаем из главы Операторы сравнения, строки сравниваются посимвольно в алфавитном порядке.
//Строчные буквы больше заглавных:

alert('a' > 'Z'); // true
/*Есть специальные методы, позволяющие получить символ по его коду и наоборот.

str.codePointAt(pos)
Возвращает код для символа, находящегося на позиции pos:

// одна и та же буква в нижнем и верхнем регистре
// будет иметь разные коды
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90
*/
//String.fromCodePoint(code)
//Создаёт символ по его коду code

alert(String.fromCodePoint(90));
// Z
//Давайте сделаем строку, содержащую символы с кодами от 65 до 220 — это латиница и ещё некоторые распространённые символы:

let st6 = '';
for (let i = 65; i <= 220; i++) {
	console.log((st6 += String.fromCodePoint(i)));
}
//делает елочку
let st7 = '';
for (let i = 65; i <= 220; i++) {
	st7 += String.fromCodePoint(i);
}
console.log(st7);
// norm
//Как видите, сначала идут заглавные буквы, затем несколько спецсимволов, затем строчные и Ö ближе к концу вывода.
//Символы сравниваются по их кодам. Больший код — больший символ. Код a (97) больше кода Z (90).
//Некоторые буквы, такие как Ö, вообще находятся вне основного алфавита. У этой буквы код больше, чем у любой буквы от a до z.
//Вызов str.localeCompare(str2) возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:
/*Отрицательное число, если str меньше str2.
Положительное число, если str больше str2.
0, если строки равны.
*/
alert('Österreich'.localeCompare('Zealand')); // -1 //результат -1 означает, что строка 'Österreich' меньше строки 'Zealand' при сравнении с учётом правил локали.
//Строки в JavaScript кодируются в UTF-16.
//str.trim() — убирает пробелы в начале и конце строки.
//str.repeat(n) — повторяет строку n раз.
