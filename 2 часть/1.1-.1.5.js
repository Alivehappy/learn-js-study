/*Как мы видим, имеется корневой объект window, который выступает в 2 ролях:

Во-первых, это глобальный объект для JavaScript-кода, об этом более подробно говорится в главе Глобальный объект.
Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.*/
//// глобальные функции доступны как методы глобального объекта:
{
	function sayHi() {
		alert('Hello');
	}
	window.sayHi();
}
//здесь мы используем window как объект окна браузера, чтобы узнать его высоту:

alert(window.innerHeight); // внутренняя высота окна браузера
//Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.
//Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице
//заменим цвет фона на красный
document.body.style.background = 'red';
// а через секунду вернём как было
setTimeout(() => (document.body.style.background = ''), 1000);
//Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа
//Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
//Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.
//Вот как мы можем использовать объект location:

{
	alert(location.href); // показывает текущий URL
	if (confirm('Перейти на Wikipedia?')) {
		location.href = 'https://wikipedia.org'; // перенаправляет браузер на другой URL
	}
}
//Функции alert/confirm/prompt тоже являются частью BOM: они не относятся непосредственно к странице, но представляют собой методы объекта окна браузера для коммуникации с пользователем
//В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.
//Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.
//Например, document.body – объект для тега <body>.
//Теги являются узлами-элементами (или просто элементами). Они образуют структуру дерева: <html> – это корневой узел, <head> и <body> его дочерние узлы и т.д.
//Текст внутри элементов образует текстовые узлы, обозначенные как #text. Текстовый узел содержит в себе только строку текста. У него не может быть потомков, т.е. он находится всегда на самом нижнем уровне.
//Пробелы и переводы строки – это полноправные символы, как буквы и цифры. Они образуют текстовые узлы и становятся частью дерева DOM. Так,
//По историческим причинам пробелы и перевод строки перед тегом <head> игнорируются
//Если мы записываем что-либо после закрывающего тега </body>, браузер автоматически перемещает эту запись в конец body, поскольку спецификация HTML требует, чтобы всё содержимое было внутри <body>. Поэтому после закрывающего тега </body> не может быть никаких пробелов.
//Если браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM.
//Например, в начале документа всегда должен быть тег <html>. Даже если его нет в документе – он будет в дереве DOM, браузер его создаст. То же самое касается и тега <body>.
/*Есть и некоторые другие типы узлов, кроме элементов и текстовых узлов.

Например, узел-комментарий:
Здесь мы видим узел нового типа – комментарий, обозначенный как #comment, между двумя текстовыми узлами.

Казалось бы – зачем комментарий в DOM? Он никак не влияет на визуальное отображение. Но есть важное правило: если что-то есть в HTML, то оно должно быть в DOM-дереве.
*/
//Все, что есть в HTML, даже комментарии, является частью DOM.

//Даже директива <!DOCTYPE...>, которую мы ставим в начале HTML, тоже является DOM-узлом. Она находится в дереве DOM прямо перед <html>.
//Даже объект document, представляющий весь документ, формально является DOM-узлом.
/*Существует 12 типов узлов. Но на практике мы в основном работаем с 4 из них:

document – «входная точка» в DOM.
узлы-элементы – HTML-теги, основные строительные блоки.
текстовые узлы – содержат текст.
комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.
*/
//Все операции с DOM начинаются с объекта document. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу.
//<html> = document.documentElement
//Самый верхний узел документа: document.documentElement. В DOM он соответствует тегу <html>.
/*<body> = document.body
Другой часто используемый DOM-узел – узел тега <body>: document.body.
<head> = document.head
Тег <head> доступен как document.head.

*/
//В частности, если скрипт находится в <head>, document.body в нём недоступен, потому что браузер его ещё не прочитал.
//Есть одна тонкость: document.body может быть равен null
//Дочерние узлы (или дети) – элементы, которые являются непосредственными детьми узла. Другими словами, элементы, которые лежат непосредственно внутри данного
//Потомки – все элементы, которые лежат внутри данного, включая детей, их детей и т.д.
//Коллекция childNodes содержит список всех детей, включая текстовые узлы.
/*
{
	<htm>
		<body>
			<div>Начало</div>
			<ul>
				<li>Информация</li>
			</ul>

			<div>Конец</div>
      <script>
        for(let i=0; i<document.body.childNodes.length; i++){
          console.log(document.body.childNodes[i])//// Text, DIV, Text, UL, ..., SCRIPT
    }

      </script>
      ...какой-то HTML-код...

		</body>
	</htm>;
}
*/
//Обратим внимание на маленькую деталь. Если запустить пример выше, то последним будет выведен элемент <script>. На самом деле, в документе есть ещё «какой-то HTML-код», но на момент выполнения скрипта браузер ещё до него не дошёл, поэтому скрипт не видит его.
//Свойства firstChild и lastChild обеспечивают быстрый доступ к первому и последнему дочернему элементу.
/*firstChild и lastChild:

Возвращают первый и последний дочерний узел любого типа (не только элементы!)
elem.firstChild === elem.childNodes[0]
elem.lastChild === elem.childNodes[elem.childNodes.length - 1]

*/
/*elem.firstElementChild  // первый дочерний ЭЛЕМЕНТ (тег)
elem.lastElementChild   // последний дочерний ЭЛЕМЕНТ
*/
//Для проверки наличия дочерних узлов существует также специальная функция elem.hasChildNodes().
/*Как мы уже видели, childNodes похож на массив. На самом деле это не массив, а коллекция – особый перебираемый объект-псевдомассив.

И есть два важных следствия из этого:

Для перебора коллекции мы можем использовать for..of:
Это работает, потому что коллекция является перебираемым объектом (есть требуемый для этого метод Symbol.iterator).

Методы массивов не будут работать, потому что коллекция – это не массив
alert(document.body.childNodes.filter); // undefined (у коллекции нет метода filter!)

*/
{
	for (let node of document.body.childNodes) {
		console.log(node);
	}
}
//Первый пункт – это хорошо для нас. Второй – бывает неудобен, но можно пережить. Если нам хочется использовать именно методы массива, то мы можем создать настоящий массив из коллекции, используя Array.from:
{
	console.log(Array.from(document.body.childNodes).filter()); //// сделали массив
}
/*DOM-коллекции, и даже более – все навигационные свойства, перечисленные в этой главе, доступны только для чтения.

Мы не можем заменить один дочерний узел на другой, просто написав childNodes[i] = ....

Для изменения DOM требуются другие методы. Мы увидим их в следующей главе*/
//Почти все DOM-коллекции, за небольшим исключением, живые. Другими словами, они отражают текущее состояние DOM.
//Если мы сохраним ссылку на elem.childNodes и добавим/удалим узлы в DOM, то они появятся в сохранённой коллекции автоматически.
//Не используйте цикл for..in для перебора коллекций
/*Коллекции перебираются циклом for..of. Некоторые начинающие разработчики пытаются использовать для этого цикл for..in.

Не делайте так. Цикл for..in перебирает все перечисляемые свойства. А у коллекций есть некоторые «лишние», редко используемые свойства, которые обычно нам не нужны:

*/
//Соседи – это узлы, у которых один и тот же родитель.
//говорят, что <body> – «следующий» или «правый» сосед <head>
//также можно сказать, что <head> «предыдущий» или «левый» сосед <body>.
//Следующий узел того же родителя (следующий сосед) – в свойстве nextSibling, а предыдущий – в previousSibling.
//Родитель доступен через parentNode.
//Навигационные свойства, описанные выше, относятся ко всем узлам в документе. В частности, в childNodes находятся и текстовые узлы и узлы-элементы и узлы-комментарии, если они есть.
alert(document.body.parentNode === document.documentElement); // выведет true
alert(document.head.nextSibling); // HTMLBodyElement
alert(document.body.previousSibling); // HTMLHeadElement
//Поэтому давайте рассмотрим дополнительный набор ссылок, которые учитывают только узлы-элементы:
/*children – коллекция детей, которые являются элементами.
firstElementChild, lastElementChild – первый и последний дочерний элемент.
previousElementSibling, nextElementSibling – соседи-элементы.
parentElement – родитель-элемент.
//alert(document.documentElement.parentNode); // #document
/*document.documentElement — это корневой элемент <html>.

parentNode возвращает любого родителя, включая:

Элементы (<div>, <body> и т.д.)

Специальные узлы (например, сам объект document).

Для <html> родителем является объект документа (#document), так как <html> — корневой элемент.
alert(document.documentElement.parentElement); // null
parentElement возвращает только родительский элемент (узлы типа Element), игнорируя остальные типы узлов.

Объект document не является DOM-элементом (это узел типа Document), поэтому:

parentElement игнорирует его → возвращает null.
document (объект Document) — это корневой узел всего DOM-дерева, но он:

Не является элементом (Element).

Имеет тип #document (а не HTMLDocumentElement или подобное).

Служит контейнером для DOM-элементов (как <html>, <body>).

document.documentElement — это уже элемент (<html>), который:

Является потомком document.

Имеет тип HTMLHtmlElement.


*/
{
	while ((elem = elem.parentElement)) {
		// идти наверх до <html>

		console.log(elem);
	}
}
{
	for (let elem of document.body.children) {
		console.log(elem); //// DIV, UL, DIV, SCRIPT
	}
}
//Если у элемента есть атрибут id, то мы можем получить его вызовом document.getElementById(id), где бы он ни находился.
/*
{
	<div id='elem'>
		<div id='elem-content'> Element</div>
	</div>;
	<script>
		// получить элемент let elem = document.getElementById('elem')
		// сделать его фон красным

		elem/style.background = 'red'
	</script>;
}
*/
//Также есть глобальная переменная с именем, указанным в id:
//elem.style.background = 'red';
//  // elem - ссылка на элемент с id="elem"
//Но это только если мы не объявили в JavaScript переменную с таким же именем, иначе она будет иметь приоритет:
//Значение id должно быть уникальным. В документе может быть только один элемент с данным id.
//Метод getElementById можно вызвать только для объекта document. Он осуществляет поиск по id по всему документу
//Самый универсальный метод поиска – это elem.querySelectorAll(css), он возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору.

/*
<ul>
<li>Этот</li>
<li>тест</li>
</ul>
<ul>
  <li>полностью</li>
  <li>пройден</li>
</ul>
<script>
let elements = document.querySelectorAll('ul>li:last-child')
for(let elem of elements){
alert(elem.innerHTML)}// "тест", "пройден"

</script>
*/
/*ul — выбирает все списки <ul>

> — означает "прямой дочерний элемент" (без вложенности)

li:last-child — выбирает последний элемент <li> внутри родителя*/
// это был Поиск по тегу
// а вот о кдассу document.querySelectorAll('.menu') // Находит элементы с class="menu"
//Метод elem.querySelector(css) возвращает первый элемент, соответствующий данному CSS-селектору.
//Иначе говоря, результат такой же, как при вызове elem.querySelectorAll(css)[0], но он сначала найдёт все элементы, а потом возьмёт первый, в то время как elem.querySelector найдёт только первый и остановится. Это быстрее, кроме того, его короче писать.
//Предыдущие методы искали по DOM.
//Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false
//Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют.
/*<a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>
<script>
for(let elem of document.body.children){
if(elem.matches('a[href$="zip]')){
alert("Ссылка на архив: " + elem.href );

}}
</script>

*/
//Предки элемента – родитель, родитель родителя, его родитель и так далее. Вместе они образуют цепочку иерархии от элемента до вершины
//Метод elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.
//Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден
//Метод element.closest() в JavaScript ищет ближайшего предка элемента, который соответствует указанному CSS-селектору, включая проверку по тегам, классам, ID и другим селекторам.
chapter.closest('ul'); // По тегу
chapter.closest('.book'); // По классу
alert(chapter.closest('.book')); // UL
alert(chapter.closest('.contents')); // DIV
/*elem.getElementsByTagName(tag) ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.
elem.getElementsByClassName(className) возвращает элементы, которые имеют данный CSS-класс.
document.getElementsByName(name) возвращает элементы с заданным атрибутом name. Очень редко используется.
*/
//// получить все элементы div в документе
let divs = document.getElementsByTagName('div');
//Коллекция — это "умный список" элементов. Индекс [0] нужен, чтобы достать конкретный элемент из этого списка. В современных проектах лучше использовать querySelector, который возвращает сразу элемент (без лишних индексов).
//Все методы "getElementsBy*" возвращают живую коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.
//Напротив, querySelectorAll возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.
//У разных DOM-узлов могут быть разные свойства. Например, у узла, соответствующего тегу <a>, есть свойства, связанные со ссылками, а у соответствующего тегу <input> – свойства, связанные с полем ввода и т.д. Текстовые узлы отличаются от узлов-элементов. Но у них есть общие свойства и методы, потому что все классы DOM-узлов образуют единую иерархию.
/*Каждый DOM-узел принадлежит соответствующему встроенному классу.

Корнем иерархии является EventTarget, от него наследует Node и остальные DOM-узлы.

*/
console.log(document.body.constructor.name); //// HTMLBodyElement
//Или мы можем просто привести его к строке:

alert(document.body); // [object HTMLBodyElement];
alert(document.body instanceof HTMLBodyElement); // true
alert(document.body instanceof HTMLElement); // true
alert(document.body instanceof Element); // true
alert(document.body instanceof Node); // true
alert(document.body instanceof EventTarget); // true
/*HTMLBodyElement
Конкретный класс только для тега <body>.

HTMLElement
Базовый класс для всех HTML-элементов (<div>, <p>, <span>).
Element
Общий класс для любых элементов (включая SVG, XML).
Node
Любые узлы DOM: элементы, текстовые узлы, комментарии.
EventTarget
Самый базовый класс для всего, что может получать события (DOM-узлы, window, XMLHttpRequest).


*/
/*Но для DOM-элементов они работают по-разному:

console.log(elem) выводит элемент в виде DOM-дерева.
console.dir(elem) выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.
*/
/*Свойство nodeType предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла.

Его значением является цифра:

elem.nodeType == 1 для узлов-элементов,
elem.nodeType == 3 для текстовых узлов,
elem.nodeType == 9 для объектов документа*/
// для объекта document значение типа -- 9
alert(document.nodeType); // 9
let elem = document.body;

// давайте разберёмся: какой тип узла находится в elem?
alert(elem.nodeType); // 1 => элемент
//Получив DOM-узел, мы можем узнать имя его тега из свойств nodeName и tagName:
alert(document.body.nodeName); // BODY
alert(document.body.tagName); // BODY
/*Есть ли какая-то разница между tagName и nodeName?

Да, она отражена в названиях свойств, но не очевидна.

Свойство tagName есть только у элементов Element.
Свойство nodeName определено для любых узлов Node:
для элементов оно равно tagName.
для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.
*/
//Другими словами, свойство tagName есть только у узлов-элементов (поскольку они происходят от класса Element), а nodeName может что-то сказать о других типах узлов.
// тегов (кроме XHTML) всегда пишутся в верхнем регистре
//Свойство innerHTML позволяет получить HTML-содержимое элемента в виде строки.
//Мы также можем изменять его. Это один из самых мощных способов менять содержимое на странице.
<body>
	<p>Параграф</p>
	<div>DIV</div>
	<script>
		alert( document.body.innerHTML )//// читаем текущее содержимое;
		document.body.innerHTML='Новый BODY!';
	</script>
</body>;
//Мы можем попробовать вставить некорректный HTML, браузер исправит наши ошибки:
//Если innerHTML вставляет в документ тег <script> – он становится частью HTML, но не запускается
//Будьте внимательны: «innerHTML+=» осуществляет перезапись
// это более короткая запись для:
elem.innerHTML = elem.innerHTML + '...';
//Свойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент.
<div id='elem'>
	Привет <b>Мир</b>
</div>;
<script>console.log(elem.outerHTML);</script>;
//// <div id="elem">Привет <b>Мир</b></div>
//Будьте осторожны: в отличие от innerHTML, запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте.
//использование outerHTML не изменяет DOM-элемент, а удаляет его из внешнего контекста и вставляет вместо него новый HTML-код.
/*<div>Привет, мир!</div>

<script>
  let div = document.querySelector('div');

  // заменяем div.outerHTML на <p>...</p>
  div.outerHTML = '<p>Новый элемент</p>'; // (*)

  // Содержимое div осталось тем же!
  alert(div.outerHTML); // <div>Привет, мир!</div> (**)
</script>
при div.outerHTML=... произошло следующее:

div был удалён из документа.
Вместо него был вставлен другой HTML <p>Новый элемент</p>.
В div осталось старое значение. Новый HTML не сохранён ни в какой переменной.
Здесь легко сделать ошибку: заменить div.outerHTML, а потом продолжить работать с div, как будто там новое содержимое. Но это не так. Подобное верно для innerHTML, но не для outerHTML.


*/
//Свойство innerHTML есть только у узлов-элементов
//У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data. Эти свойства очень похожи при использовании, есть лишь небольшие различия в спецификации. Мы будем использовать data, потому что оно короче
/*
<body>
  Привет
  <!-- Комментарий -->
	<script>
		let text = document.body.firstChild;
		console.log(text.data);// Привет
		let comment = text.nextSibling;
		alert(comment.data); // Комментарий

</script>
</body>*/
//Свойство textContent предоставляет доступ к тексту внутри элемента за вычетом всех <тегов>.
