{
	function loadScript(src, callback) {
		let script = document.createElement('script');
		script.src = src;
		script.onload = () => callback(null, script);
		script.onerror = () =>
			callback(new Error(`Не удалось загрузить скрипт ${src}`));
	}
}
//onload и onerror — это специальные обработчики событий для элементов <script> в JavaScript. Они позволяют отслеживать успешную загрузку скрипта или ошибки.
/*Опять же, подход, который мы использовали в loadScript, также распространён и называется «колбэк с первым аргументом-ошибкой» («error-first callback»).

Правила таковы:

Первый аргумент функции callback зарезервирован для ошибки. В этом случае вызов выглядит вот так: callback(err).
Второй и последующие аргументы — для результатов выполнения. В этом случае вызов выглядит вот так: callback(null, result1, result2…).
*/
{
	loadScript('/my/script.js', function (error, script) {
		if (error) {
			handleError(error);
			// обрабатываем ошибку
		} else {
			// скрипт успешно загружен
		}
	});
}
//Адская пирамида вызовов
/*
{
	loadScript('1.js', function (error, script) {
		if (error) {
			handleError(error);
		} else {
			// ...
			loadScript('2.js', function(error, script) {
				if (error) {
					handleError(error);
				} else {
					// ...
					loadScript('3.js', function (error, script) {
						if (error) {
							handleError(error);
						} else {
							// ...и так далее,
						}
					});
					*/
/*Мы загружаем 1.js. Продолжаем, если нет ошибок.
Мы загружаем 2.js. Продолжаем, если нет ошибок.
Мы загружаем 3.js. Продолжаем, если нет ошибок*/
/*Пирамида вложенных вызовов растёт вправо с каждым асинхронным действием. В итоге вы сами будете путаться, где что есть.

*/
/*Promise (по англ. promise, будем называть такой объект «промис») – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. В терминах нашей аналогии – это «список для подписки». «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов*/
//let promise = new Promise(function (resolve, reject) {// функция-исполнитель (executor)
// "певец"});
//Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически
//Она должна содержать «создающий» код, который когда-нибудь создаст результат. В терминах нашей аналогии: исполнитель – это «певец».
//Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.
/*Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:

resolve(value) — если работа завершилась успешно, с результатом value.
reject(error) — если произошла ошибка, error – объект ошибки*/
/*state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error)*/
//Промис – и успешный, и отклонённый будем называть «завершённым», в отличие от изначального промиса «в ожидании».
//Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы .then/.catch/.finally,
