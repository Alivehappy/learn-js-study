result = a || b;
alert  (true || true)//true
alert (false || true)// true
alert( true || false)// true
alert(false|| false)// false

if (1 || 0){
    alert('истинно');
}
let hour = 9;
if (hour < 10 || hour> 18 ){
    alert ("Office is closed");
} else{
    alert(' U r welcome');}

    let hour = 12
    let isWeekend = true;
    if(hour < 10 || hour >18 || isWeekend){
        alert("Office is closed")
    }
a ||= b    //       a || ( a= b );
let joHasCar = false
joHasCar ||= "Jo does not have a car"
alert(joHasCar)//'Jo does not have a car' если первон значение ложно идем кр второму с равно

let manufacurer = ''    // false
manufacurer ||= "Unfamiliar manufacturer"
alertt(manufacurer);

value = a && b // И возвращает true, есл и оба аргумента истинны, а иначе – false:
alert(true && true)//true
alert(false && true) //false
alert(true&&false)//false
alert(false&&false)//false

if (1 && 0) { // вычисляется как true && false
    alert( "не сработает, так как результат ложный" );
  }
  //И «&&» находит первое ложное значение
При нескольких подряд операторах И:

result = value1 && value2 && value3
/*Если результат false, останавливается и         возвращает исходное значение этого операнда.
Если все операнды были истинными, возвращается последний//
//Другими словами, И озвращает первое ложное значение.//
*/
alert(1&&0)//вернем 0 (false), так как 1 - истинно
alert(1 && 5 )//5 последнее истинное значение
alert(null && 5)//null если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert( 0 && "какая-то строка" ); // 0

alert( 1 && 2 && null && 3 ); // null
alert( 1 && 2 && 3 ); // 3


a&&=b   // a&&(a=b)
let greeting = "Привет"; // строка непустая, поэтому будет преобразована к логическому значению true

greeting &&= greeting + ", пользователь!"; // оператор &&= выполняет присваивание, если левая часть истинна

alert(greeting); // "Привет, пользователь!"
/*Если бы greeting было пустой строкой (""), оператор &&= не изменил бы значение greeting, и в alert отобразился бы пустой текст.
Этот подход позволяет легко добавлять к строке суффикс, если строка уже содержит значение, и избежать лишних операций в случае пустых строк.
*/

let greeting = "hello";
if(greeting){
    greeting = greeting +", user"
}alert( greeting )

/*Оператор принимает один аргумент и выполняет следующие действия:

Сначала приводит аргумент к логическому типу true/false.
Затем возвращает противоположное значение.То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое.

Есть немного более подробный способ сделать то же самое – встроенная функция Boolean:

alert( Boolean("непустая строка
*/
alert( !true ); // false
alert( !0 ); // true
alert( !!"непустая строка" ); // true
alert( !!null ); // false
/*a ||= b;
Оператор ||= принимает два операнда и выполняет следующие действия:

Вычисляет операнды слева направо.
Конвертирует a в логическое значение.
Если a ложно, присваивает a значение b.
a &&= b;
Принцип действия &&= практически такой же, как и у оператора логического присваивания ИЛИ ||=. Единственное отличие заключается в том, что &&= присвоит a значение b только в том случае, если a истинно.

alert( alert(1) && alert(2) );
Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

Поэтому до правого alert дело не дойдёт, вычисления закончатся на левом.

alert( null || 2 && 3 || 4 );
Приоритет оператора && выше, чем ||, поэтому он выполнится первым.

Результат 2 && 3 = 3, поэтому выражение приобретает вид:

null || 3 || 4
Теперь результатом является первое истинное значение: 3.
*/

let value = NaN;
value &&=10//nan
value ||=20//20
value &&=30//30
value||=40//30

let age;
if(age >= 14 && age <= 90);
if(!(age >= 14 && age <= 90));
if(age<14 || age > 90);

if (-1 || 0) alert( 'first' );
if (-1 && 0) alert( 'second' );
if (null || -1 && 1) alert( 'third' );
решение
Ответ: первое и третье выполнятся.

Подробности:

// Выполнится.
// Результат -1 || 0 = -1, в логическом контексте true
if (-1 || 0) alert( 'first' );

// Не выполнится
// -1 && 0 = 0,  в логическом контексте false
if (-1 && 0) alert( 'second' );

// Выполнится
// оператор && имеет больший приоритет, чем ||
// так что -1 && 1 выполнится раньше
// вычисления: null || -1 && 1  ->  null || 1  ->  1
if (null || -1 && 1) alert( 'third' );


let login  = prompt ("What is ur login",'');
if(login === "admin"){
    let password = prompt("What is ur password",'');
    if(password === 'я главный'){
        alert("Hello")
    } else if (password ==="" || password === null){
        alert("Canceled")
    } else {
        alert("Wrong password")
    };
} else if(login ==="" || login === null) {
    alert("Canceled");
 } else {
        alert("i dont know u");
    }
    result = a ?? b, используя уже знакомые нам операторы:

    result = (a !== null && a !== undefined) ? a : b;

    let user;

alert(user ?? "Аноним"); // Аноним (user не существует)
let user = "Иван";

alert(user ?? "Аноним"); // Иван (user существует)

let a = null;
let b = null;
let c = "Coder";
alert( a ?? b ?? c ?? "anon")// coder
// || возвращает первое истинное значение.  ?? возвращает первое определённое значение.
/*Проще говоря, оператор || не различает false, 0, пустую строку "" и null/undefined. Для него они все одинаковы, т.е. являются ложными значениями. Если первым аргументом для оператора || будет любое из перечисленных значений, то в качестве результата мы получим второй аргумент.*/
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
let height = null;
let width = null;

// важно: используйте круглые скобки
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000

let x = (1 && 2) ?? 3; // Работает без ошибок

alert(x); // 2
let r = null;
if( r === null || r === undefined){
    r = 18;
}
x??=y//Оператор ??= присвоит x значение y только в том случае, если x не определено (null/undefined).
let r = null;
r ??= 18;
alert(r)//18
//Обратите внимание: если бы userAge не был равен null/undefined, то выражение справа от ??= никогда бы не выполнилось:

let userAge = 18;

userAge ??= alert("не сработает");
userAge ??= 21;
userAge ??= null;

alert(userAge) // по-прежнему 18
Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем у ? и =, поэтому при использовании его в выражении, скорее всего, потребуются скобки.

Запрещено использовать вместе с || или && без явно указанного приоритета, то есть без скобок.

Для присвоения переменной значения в зависимости от того, «определена» она или нет, используется оператор нулевого присваивания ??=.

Задачи
alert(undefined ?? NaN ?? null ?? "" ?? " ");
решение
Ответ: NaN. Это первое «определённое» значение.

alert(undefined ?? NaN ?? null ?? "" ?? " ");
let city = null;

city ??= "Берлин";
city ??= null;
city ??= "Кёльн";
city ??= "Гамбург";

alert(city);
решение
Ответ: "Берлин".

Первое присваивание city ??= "Берлин" срабатывает, поскольку изначально city — это null. После присваивания все остальные действия с оператором ??= становятся бессмысленными, так как теперь city содержит «определённое» значение.

let num1 = 10;
let num2 = 20;
let result;//undefined
if(result === null || result === undefined){
    if (num1 !== null && num1 !== undefined){
        result = num1;
    }
} else{
    result = num2;
}
}
result??=num1 ?? num2



