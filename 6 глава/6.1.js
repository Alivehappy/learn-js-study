//Рекурсия — это когда функция вызывает саму себя
/*pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16*/

//1.Итеративный способ: цикл for:
function pow(x, n) {
	let result = 1;
	for (let i = 0; i < n; i++) {
		result *= x;
	}
	return result;
}
console.log(pow(2, 4)); //16
//2.
function pow(x, n) {
	if (n == 1) {
		//Когда n равно 1, функция возвращает x, так как любое число в степени 1 равно самому себе.

		return x;
	} else {
		return x * pow(x, n - 1);
	}
}
alert(pow(2, 3)); // 8
//Если n == 1, тогда всё просто. Эта ветвь называется базой рекурсии, потому что сразу же приводит к очевидному результату: pow(x, 1) равно x
//Мы можем представить pow(x, n) в виде: x * pow(x, n - 1). Что в математике записывается как: xn = x * xn-1. Эта ветвь – шаг рекурсии: мы сводим задачу к более простому действию (умножение на x) и более простой аналогичной задаче (pow с меньшим n). Последующие шаги упрощают задачу всё больше и больше, пока n не достигает 1.

//Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. В нашем случае она будет равна n.
//Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов
//то есть получая базовоае значение 2 оно поднимается вверх и просто каждый раз умножает себя на 2
//Каждый вызов pow порождает новый вызов (если n > 1), и только когда n = 1, начинается процесс возврата значений.
/*pow(2, 4) = 2 * pow(2, 3)
pow(2, 3) = 2 * pow(2, 2)
pow(2, 2) = 2 * pow(2, 1)
pow(2, 1) = 2
*/
function pow(x, n) {
	return n == 1 ? x : x * pow(x, n - 1);
}
//Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (execution context)
/*Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this (мы не используем его в данном примере) и прочую служебную информацию.*/
//Один вызов функции имеет ровно один контекст выполнения, связанный с ним
/*Каждый вызов функции создаёт контекст выполнения, который помещается в стек вызовов.

При вложенном вызове текущая функция приостанавливается, а новая — выполняется.

После завершения вложенной функции её контекст удаляется из стека, и выполнение внешней функции продолжается.

//Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, и в данном случае это приводит к тому, что возведение в степень n хранит в памяти n различных контекстов.

Реализация возведения в степень через цикл гораздо более*/
let company = {
	sales: [
		{
			name: 'John',
			salary: 1000,
		},
		{
			name: 'Alice',
			salary: 600,
		},
	],

	development: {
		sites: [
			{
				name: 'Peter',
				salary: 2000,
			},
			{
				name: 'Alex',
				salary: 1800,
			},
		],

		internals: [
			{
				name: 'Jack',
				salary: 1300,
			},
		],
	},
};
{
	let company = {
		sales: [
			{ name: 'John', salary: 1000 },
			{ name: 'Alice', salary: 600 },
		],
		development: {
			sites: [
				{ name: 'Peter', salary: 2000 },
				{ name: 'Alex', salary: 1800 },
			],
			internals: [{ name: 'Jack', salary: 1300 }],
		},
	};
	// Функция для подсчёта суммы зарплат

	function sumSalaries(department) {
		if (Array.isArray(department)) {
			// случай (1)
			return department.reduce((prev, current) => prev + current.salary, 0); // сумма элементов массива
		} else {
			// случай (2)
			let sum = 0;
			for (let subdep of Object.values(department)) {
				sum += sumSalaries(subdep); // рекурсивно вызывается для подотделов, суммируя результаты
			}
			return sum;
		}
	}

	alert(sumSalaries(company)); // 6700
}
/*sumSalaries(company.sales) // передали массив -> случай 1
sumSalaries(company.development) // передали объект -> случай 2
*/
/*Элемент связанного списка определяется рекурсивно как объект с:

value,
next – свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент.
*/
let list = {
	value: 1,
	next: {
		value: 2,
		next: {
			value: 3,
			next: {
				value: 4,
				next: null,
			},
		},
	},
};
//let
list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
/*Здесь мы можем ещё лучше увидеть, что есть несколько объектов, каждый из которых имеет value и next, указывающий на соседа. Переменная list является первым объектом в цепочке, поэтому, следуя по указателям next из неё, мы можем попасть в любой элемент.

Список можно легко разделить на несколько частей и впоследствии объединить обратно:

*/
//Список можно легко разделить на несколько частей и впоследствии объединить обратно:

let secondList = list.next.next;
list.next.next = null;
{
	let list = { value: 1 };
	list.next = { value: 2 };
	list.next.next = { value: 3 };
	list.next.next.next = { value: 4 };
	list.next.next.next.next = null;
	// добавление нового элемента в список
	list = { value: 'new item', next: list };
	//Чтобы удалить элемент из середины списка, нужно изменить значение next предыдущего элемента:
	list.next = list.next.next;
	//list.next перепрыгнуло с 1 на значение 2. Значение 1 теперь исключено из цепочки. Если оно не хранится где-нибудь ещё, оно будет автоматически удалено из памяти.
}
//Главным недостатком является то, что мы не можем легко получить доступ к элементу по его индексу. В простом массиве: arr[n] является прямой ссылкой. Но в списке мы должны начать с первого элемента и перейти в next N раз, чтобы получить N-й элемент.
//Когда функция вызывает саму себя, это называется шагом рекурсии.
//База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.

function sum(a, b) {
	return a + b;
}
console.log(sum(1, 2, 3, 4, 5)); //1+2=3
/*Лишние аргументы не вызовут ошибку. Но, конечно, посчитаются только первые два.

Остаточные параметры могут быть обозначены через три точки .... Буквально это значит: «собери оставшиеся параметры и положи их в массив».

*/
function sumAll(...args) {
	// args — имя массива
	let sum = 0;
	for (let arg of args) {
		sum += arg;
	}
	return sum;
}
console.log(sumAll(1, 2, 3, 4, 5)); //15
{
	function sumAll() {
		let sum = 0;
		for (let i = 0; i < arguments.length; i++) {
			sum += arguments[i];
		}
		return sum;
	}
	console.log(sumAll(1, 2, 3, 4, 5));
}
/*Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator, как было описано выше.
Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы. Например, строки итерируемы (для них работает for..of) и являются псевдомассивами (они индексированы и есть length).

И итерируемые объекты, и псевдомассивы – это обычно не массивы, у них нет методов push, pop 
*/
//Array.from в строке (*) принимает объект, проверяет, является ли он итерируемым объектом или псевдомассивом, затем создаёт новый массив и копирует туда все элементы
function showName(firsstName, lastName, ...titles) {
	console.log(firsstName + ' ' + lastName);

	// Юлий Цезарь

	// Оставшиеся параметры пойдут в массив
	// titles = ["Консул", "Император"]
	console.log(titles[0]);
	console.log(titles[1]);
	console.log(titles.length);
}
showName('Юлий', 'Цезарь', 'Консул', 'Император');
//Остаточные параметры собирают все остальные аргументы, поэтому бессмысленно писать что-либо после них. Это вызовет ошибку:
//Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.
{
	function showName() {
		console.log(arguments.length);
		console.log(arguments[0]);
		console.log(arguments[1]);
		Array.from(arguments).forEach(arg => console.log(arg));
	}
	showName('Юлий', 'Цезарь'); // Вывод: 2, Юлий, Цезарь

	//  // Объект arguments можно перебирать
	// for(let arg of arguments)alert(arg)
	showName('Илья'); // Вывод: 1, Илья, undefined (второго аргумента нет)
}
/*arguments = {
  0: 'Юлий',
  1: 'Цезарь',
  length: 2,
  callee: ссылка_на_функцию, // Устарело
  __proto__: Object.prototype
}
	Хотя arguments похож на массив, и его тоже можно перебирать, это всё же не массив. Он не поддерживает методы массивов
*/
//Если мы обратимся к arguments из стрелочной функции, то получим аргументы внешней «нормальной» функции.Как мы помним, у стрелочных функций нет собственного this. Теперь мы знаем, что нет и своего объекта arguments.
//При использовании rest-параметров (...args) вы получаете настоящий массив со всеми его методами, в отличие от псевдомассива arguments.
/*В JavaScript обычные объекты (как {a: 1, b: 5}) не являются итерируемыми по умолчанию, поэтому их нельзя напрямую преобразовать в массив ни через spread-оператор ([...obj]), ни через Array.from(obj). */
{
	let arr = [3, 5, 1];

	alert(Math.max(arr)); // NaN
	//Конечно, мы можем вводить числа вручную :
	//Math.max(arr[0], arr[1], arr[2]) Но, во-первых, это плохо выглядит, а, во-вторых, мы не всегда знаем, сколько будет аргументов. Их может быть как очень много, так и не быть совсем.
}
/*И тут нам поможет оператор расширения. Он похож на остаточные параметры – тоже использует ..., но делает совершенно противоположное.

Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов.

*/
{
	let arr = [3, 5, 1];
	console.log(Math.max(...arr)); // 5 (оператор "раскрывает" массив в список аргументов)
}
{
	let arr1 = [1, -2, 3, 4];
	let arr2 = [8, 3, -8, 1];
	console.log(Math.max(...arr1, ...arr2));
}
//Spread-оператор (...) "разворачивает" массивы:
{
	let arr1 = [1, -2, 3, 4];
	let arr2 = [8, 3, -8, 1];

	console.log(Math.max(1, ...arr1, 2, ...arr2, 25)); //25
}
//Оператор расширения можно использовать и для слияния массивов
{
	let arr = [3, 5, 1];
	let arr2 = [8, 9, 15];
	let merged = [0, ...arr, 2, ...arr2];
	alert(merged); // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)
}
//Например, оператор расширения подойдёт для того, чтобы превратить строку в массив символов:

let str = 'Привет';
console.log([...str]); // П,р,и,в,е,т
//Посмотрим, что происходит. Под капотом оператор расширения использует итераторы, чтобы перебирать элементы. Так же, как это делает for..of.
//Цикл for..of перебирает строку как последовательность символов, поэтому из ...str получается "П", "р", "и", "в", "е", "т". Получившиеся символы собираются в массив при помощи стандартного объявления массива: [...str].
{
	//Для этой задачи мы можем использовать и Array.from. Он тоже преобразует перебираемый объект (такой как строка) в массив:

	let str = 'Привет';

	// Array.from преобразует перебираемый объект в массив
	alert(Array.from(str)); // П,р,и,в,е,т
}
//Array.from работает как с псевдомассивами, так и с итерируемыми объектами
//Оператор расширения работает только с итерируемыми объектами
//итерируемые объекты это что с символом итератормо, строки мап и сет массивы
//Напишите функцию sumTo(n), которая вычисляет сумму чисел 1 + 2 + ... + n.
/*sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050*/
function sumTo(num) {
	if (num === 1) {
		return num;
	} else {
		return num + sumTo(num - 1);
	}
}
sumTo(3); //6
{
	function sumTo(num) {
		let result = 0;
		for (let i = 0; i <= num; i++) {
			result += i;
		}
		return result;
	}
	sumTo(3); //6
}
{
	function sumTo(num) {
		return (num * (num + 1)) / 2;
	}
	sumTo(3); // 6
}
//что решение по формуле работает быстрее всех? Это очевидно. Оно использует всего три операции для любого n, а цикл и рекурсия требуют как минимум n операций сложения.
//n! = n * (n - 1) * (n - 2) * ...*1
function factorial(n) {
	if (n === 1) {
		return n;
	} else {
		return n * factorial(n - 1); // факториал 1 равен 1
	}
}
console.log(factorial(5)); //120
{
	function factorial(n) {
		let sum = 1;
		for (let i = 1; i <= n; i++) {
			sum *= i;
		}
		return sum;
	}
	console.log(factorial(5)); //120
}
//n! = n * (n-1)!
{
	function factorial(n) {
		return n != 1 ? n * factorial(n - 1) : 1;
	}
}

{
	function fibonacci(n) {
		if (n <= 1) {
			return n;
		} else {
			return fibonacci(n - 1) + fibonacci(n - 2);
		}
	}
	console.log(fibonacci(5));
}
{
	function fib(n) {
		if (n <= 1) return n;
		let a = 0,
			b = 1;
		for (let i = 2; i <= n; i++) {
			[a, b] = [b, a + b];
		}
	}
}
