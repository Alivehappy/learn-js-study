// let func = new Function([arg1, arg2, ...argN], functionBody)
let sum = new Function('a', 'b', 'return a+b');
console.log(sum(1, 2)); //3
let sayHi = new Function('alert'('Hello'));
sayHi(); //Hello
//Главное отличие от других способов объявления функции, которые были рассмотрены ранее, заключается в том, что функция создаётся полностью «на лету» из строки, переданной во время выполнения.
//Но new Function позволяет превратить любую строку в функцию. Например, можно получить новую функцию с сервера и затем выполнить её:

/*let str = //...код, полученный с сервера динамически
  let func = new Function(str);
func();*/

/*когда функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное. Поэтому такая функция имеет доступ только к глобальным переменным.
Когда вы создаете функцию с использованием конструктора new Function, она не имеет доступа к лексическому окружению, в котором была создана. Вместо этого, её [[Environment]] ссылается на глобальное окружение. Это означает, что такая функция может обращаться только к глобальным переменным и параметрам, которые ей передаются.



*/
function getFunc() {
	let value = 'test';
	let func = new Function('alert'(value));
	return func;
}
getFunc()(); // ошибка: value не определено
/*getFunc()() — это вызов этой возвращенной функции. Это означает, что вы сначала вызываете getFunc, чтобы получить функцию func, а затем вызываете func, что приводит к выполнению alert(value).
 */
/*setTimeout позволяет вызвать функцию один раз через определённый интервал времени.

setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);
Параметры:

func|code
Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.
delay
Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.
arg1, arg2…
Аргументы, передаваемые в функцию
*/
{
	function sayHi1() {
		alert('Привет');
	}
	setTimeout(sayHi1, 1000);
}

{
	function sayHi2(phrase, who) {
		alert(phrase + ', ' + who);
	}
	setTimeout(sayHi2, 1000, 'Привет', 'Джон'); //// Привет, Джон
}
{
	setTimeout('alert("Привет")', 1000);
}
//использование строк не рекомендуется. Вместо этого используйте функции
setTimeout(() => alert('Привет'), 1000);
/*// неправильно!
setTimeout(sayHi(), 1000);
Это не работает, потому что setTimeout ожидает ссылку на функцию. Здесь sayHi() запускает выполнение функции, и результат выполнения отправляется в setTimeout. В нашем случае результатом выполнения sayHi() является undefined (так как функция ничего не возвращает), поэтому ничего не планируется.

*/
//Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.

/*let timerId = setTimeout(...);
clearTimeout(timerId)*/
let timerId = setTimeout(() => alert('ничего не происходит'), 1000);
alert(timerId); //// идентификатор таймера

clearTimeout(timerId);
alert(timerId); //// тот же идентификатор (не принимает значение null после отмены)
/*Метод setInterval имеет такой же синтаксис как setTimeout:

let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
Но отличие этого метода от setTimeout в том, что функция запускается не один раз, а периодически через указанный интервал времени.
Чтобы остановить дальнейшее выполнение функции, необходимо вызвать clearInterval(timerId).
*/
let timerId1 = setInterval(() => alert('tick'), 2000);
// повторить с интервалом 2 секунды
// остановить вывод через 5 секунд
setTimeout(() => {
	clearInterval(timerId1);
	alert('stop');
}, 5000);
/** вместо:
let timerId = setInterval(() => alert('tick'), 2000);
*/
{
	let timerId = setTimeout(function tick() {
		alert('tick');
		timerId = setTimeout(tick, 2000);
	}, 2000);
}
/*Новый таймер срабатывает через 2 секунды после предыдущего выполнения

Снова показывает alert

Снова устанавливает новый таймер
Следующий вызов начнётся только после завершения предыдущего

Нет наложения вызовов, если alert долго не закрывают
код с цепочкой setTimeout действительно создаёт бесконечный цикл вызовов, полностью аналогичный setInterval, но с более контролируемым поведением. Это не 2 вызова, а потенциально бесконечное количество, так как каждый вызов планирует следующий



{
	let delay = 5000;
	let timerId = setTimeout(function requet() {
		//  ...отправить запрос...
		//ошибка запроса из-за перегрузки сервера) 
		// if(){ delay *=2
	}
	timerId = setTimeout(request, delay)
	});
}
Вложенный setTimeout позволяет задать задержку между выполнениями более точно, чем setInterval.

*/
{
	let i = 1;
	setInterval(function () {
		func(i);
	}, 100);
}
//В данном случае движок ждёт окончания выполнения func и затем проверяет планировщик и, если время истекло, немедленно запускает его снова

{
	let i = 0;
	setTimeout(function run() {
		func(i);
		setTimeout(run, 100);
	}, 100);
}
//ВложенныйsetTimeout гарантирует фиксированную задержку (здесь 100 мс)
//// функция остаётся в памяти до тех пор, пока планировщик обращается к ней
{
	setTimeout(() => alert('Mir'));
	alert('Hi');
}
/*После того как alert("Привет") закрыт, стек вызовов пуст.
Только после этого JavaScript проверяет очередь выполнения и выполняет запланированную функцию () => alert("Мир").
setTimeout является асинхронной функцией, что означает, что она не блокирует выполнение остального кода
Функция обратного вызова из setTimeout все равно помещается в очередь событий и выполняется только после того, как стек вызовов пуст.

*/

let start = Date.now();
let times = [];
setTimeout(function run() {
	times.push(Date.now() - start); // запоминаем задержку от предыдущего вызова
	if (start + 100 < Date.now())
		alert(times); // показываем задержку через 100 мс
	else setTimeout(run);
});
/*setInterval не учитывает время выполнения функции обратного вызова, что может привести к накоплению вызовов.
Вложенные setTimeout автоматически учитывают время выполнения, так как следующий вызов планируется после завершения текущего.
*/
{
	function printNumbers(from, to) {
		let current = from;
		setTimeout(function go() {
			console.log(current);
			if (current < to) {
				setTimeout(go, 1000);
			}
			current++;
		}, 1000);
	}
	console.log(printNumbers(0, 5));
}

{
	function printNumbers(from, to) {
		let current = from;
		function print() {
			console.log(current);
			if (current < to) {
				current++;
				setTimeout(print, 1000);
			}
		}
		print();
	}
	printNumbers(0, 5);
}

{
	function printNumbers(from, to) {
		let current = from;
		let timerId = setInterval(function () {
			console.log(current);
			if (current === to) {
				clearInterval(timerId);
			}
			current++;
		}, 1000);
	}
	printNumbers(0, 5);
}
