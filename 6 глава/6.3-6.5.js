//Если переменная объявлена внутри блока кода {...}, то она видна только внутри этого блока.
{
	// показать сообщение

	let message = 'Hello';
	console.log(message);
}

{
	// показать другое сообщение

	let message = 'Hi';
	console.log(message);
}
/*Без блоков была бы ошибка
Обратите внимание, что без отдельных блоков возникнет ошибка, если мы используем let с существующим именем переменной:

// показать сообщение
let message = "Hello";
alert(message);

// показать другое сообщение
let message = "Goodbye"; // SyntaxError: Identifier 'message' has already been declared
alert(message);
*/
//Для if, for, while и т.д. переменные, объявленные в блоке кода {...}, также видны только внутри:

function sayHiBye(firstName, lastName) {
	function getFullName() {
		return firstName + ' ' + lastName;
	}
	console.log('Hello, ' + getFullName());
	console.log('Bye, ' + getFullName());
}
sayHiBye('Tim', 'Russ');

function makeCounter() {
	let count = 0;
	return function () {
		return count++; // есть доступ к внешней переменной "count"  // Сначала возвращает, потом увеличивает
	};
}
console.log(makeCounter()); //Вы выводите саму возвращаемую функцию, а не результат её вызова.
// Создаём экземпляр счётчика
const counter = makeCounter();

// Вызываем счётчик несколько раз
console.log(counter()); // 0

//В начале каждого вызова makeCounter() создается новый объект лексического окружения, в котором хранятся переменные для конкретного запуска makeCounterТаким образом, мы имеем два вложенных лексических окружения, как в примере выше:

//Отличие заключается в том, что во время выполнения makeCounter() создается крошечная вложенная функция, состоящая всего из одной строки: return count++. Мы ее еще не запускаем, а только создаем.
//Все функции помнят лексическое окружение, в котором они были созданы. Технически здесь нет никакой магии: все функции имеют скрытое свойство [[Environment]
/*Переменная count создаётся каждый раз при вызове makeCounter()

Возвращаемая функция сохраняет ссылку на эту конкретную переменную

Каждый вызов makeCounter() создаёт новое лексическое окружение
Таким образом, counter.[[Environment]] имеет ссылку на {count: 0} лексического окружения. Так функция запоминает, где она была создана, независимо от того, где она вызывается. Ссылка на [[Environment]] устанавливается один раз и навсегда при создании функции.


Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. 
*/
function f() {
	let value = Math.random();
	return function () {
		alert(value);
	};
}
// 3 функции в массиве, каждая из которых ссылается на лексическое окружение
// из соответствующего вызова f()
let arr = [f(), f(), f()];
//я сохраняю ррезуьтат вызхову, где было замыкания
//Объект лексического окружения исчезает, когда становится недоступным (как и любой другой объект). Другими словами, он существует только до тех пор, пока на него ссылается хотя бы одна вложенная функция.
//Лексическое окружение создаётся при вызове функции
//Каждый раз, когда функция выполняется, для неё создаётся новое лексическое окружение, где хранятся её локальные переменные, аргументы и ссылка на внешнее окружение.
//Обычно оно удаляется после выполнения функции

//Если внутри функции нет вложенных функций, которые сохраняют на него ссылку, то после завершения функции окружение удаляется
{
	function f() {
		let value = 123;
		return function () {
			alert(value);
		};
	}
	let g = f(); // пока существует функция g, value остается в памяти
	g = null;
} // ...и теперь память очищена.

function sum(a) {
	return function (b) {
		return a + b; // берёт "a" из внешнего лексического окружения
	};
}
console.log(sum(1)(3)); //4
/*let x = 1;

function func() {
  console.log(x); // ?// ReferenceError: Cannot access 'x' before initialization


  let x = 2;
}

func();
ак вы могли прочитать в статье Область видимости переменных, замыкание, переменная находится в неинициализированном состоянии с момента входа в блок кода (или функцию). И остается неинициализированной до соответствующего оператора let.

Другими словами, переменная технически существует, но не может быть использована до let.
// локальная переменная x известна движку с самого начала выполнения функции,
  // но она является неинициализированной до let ("мёртвая зона")
  // следовательно, ошибка
	Эту зону временной непригодности переменной (от начала блока кода до let) иногда называют «мёртвой зоной».


*/
let array = [1, 2, 3, 4, 5, 6, 7];
function inBetween(a, b) {
	return function (x) {
		return x >= a && x <= b;
	};
}
function inArray(array) {
	return function (x) {
		return array.includes(x);
	};
}
alert(array.filter(inBetween(3, 6))); // 3,4,5,6
alert(array.filter(inArray([1, 2, 10]))); // 1,2

let users = [
	{ name: 'Иван', age: 20, surname: 'Иванов' },
	{ name: 'Пётр', age: 18, surname: 'Петров' },
	{ name: 'Анна', age: 19, surname: 'Каренина' },
];
const sorted = users.sort((a, b) => a.age - b.age); // сс цифрами работает
console.log(sorted);
//Сравниваем a.name и b.name как строки

const sorted1 = users.sort((a, b) => (a.name > b.name ? 1 : -1));
//Если a.name алфавитно больше чем b.name → возвращаем 1 (значит a должен быть после b)
const sorted2 = users.sort((a, b) => (a.age > b.age ? 1 : -1));
function byField(fieldName) {
	return a[fieldName] > b[fieldName] ? 1 : -1;
}
users.sort(byField('age'));

function sayHi() {
	console.log('Hi');
	sayHi.counter++;
}
sayHi.counter = 0;
console.log(sayHi.name); // sayHi
{
	function f(sayHi = function () {}) {
		console.log(sayHi.name);
	}
}
/*= function() {} - значение по умолчанию для этого параметра

Если функция вызывается без аргумента: f()

Или с явным undefined: f(undefined)

То параметр sayHi получит это значение по умолчанию
Также имена имеют и методы объекта:

let user = {

  sayHi() {
    // ...
  },

  sayBye: function() {
    // ...
  }

}

alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye

*/

let arr3 = [function () {}];
console.log(arr3[0].name); // <пустая строка>
// здесь отсутствует возможность определить имя, поэтому его нет
//Ещё одно встроенное свойство «length» содержит количество параметров функции в её объявлении
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}
alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
//Как мы видим, троеточие, обозначающее «остаточные параметры», здесь как бы «не считается

function ask(question, ...handlers) {
	let isYes = confirm(question);
	for (let handler of handlers) {
		if (handler.length == 0) {
			//// Если обработчик не принимает параметров

			if (isYes) handler(); // Вызываем только при положительном ответе
		} else {
			handler(isYes); // Всегда вызываем, передавая результат
		}
	}
}
// для положительных ответов вызываются оба типа обработчиков
// для отрицательных - только второго типа
//...handlers - массив функций-обработчиков (rest-параметр)
//замыкания не даетдоступ к локаьным перменным в глобал коде а свйоства функции дают
{
	let sayHi = function func(who) {
		alert(`Hello, ${who}`);
	};
	sayHi('John'); // Hello, John
}
/*Есть две важные особенности имени func, ради которого оно даётся:

Оно позволяет функции ссылаться на себя же.
Оно не доступно за пределами функции.
Необязательное имя, которое можно вставить в Function Expression, как раз и призвано решать  проблемы,к огда не передали параментр, чтоб потом при ренейминге большр функци не быо ошибок, нам нужно второе имя, коорое можно вызывать пр пкстом аргументе
Теперь всё работает, потому что имя "func" локальное и находится внутри функции. Теперь оно взято не снаружи (и недоступно оттуда). Спецификация гарантирует, что оно всегда будет ссылаться на текущую функцию.

Внешний код все ещё содержит переменные sayHi и welcome, но теперь func – это «внутреннее имя функции», таким образом она может вызвать себя изнутри
*/
let sayHi = function func(who) {
	if (who) {
		alert(`hello, ${who}`);
	} else {
		func('Guest');
	}
};
let welcome = sayHi;
sayHi = null;
welcome(); // Hello, Guest (вложенный вызов работает)
/*Трюк с «внутренним» именем, описанный выше, работает только для Function Expression и не работает для Function Declaration. Для Function Declaration синтаксис не предусматривает возможность объявить дополнительное «внутреннее» имя.

Зачастую, когда нам нужно надёжное «внутреннее» имя, стоит переписать Function Declaration на Named Function Expression.

*/ {
	function makeCounter(value) {
		let count = value || 0;
		function counter() {
			count++;
			return count;
		}
		(counter.set = function (value) {
			count = value;
		}),
			(counter.decrease = function () {
				count--;
			});
		return counter;
	}
	const counter = makeCounter(10);

	console.log(counter()); // 10
	console.log(counter()); // 11
}

{
}
